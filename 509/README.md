# 509. 斐波那契数

## 描述

斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：

F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1
给定 n ，请计算 F(n) 。

## 示例 1

输入：n = 2
输出：1
解释：F(2) = F(1) + F(0) = 1 + 0 = 1

## 示例 2

输入：n = 3
输出：2
解释：F(3) = F(2) + F(1) = 1 + 1 = 2

## 示例 3

输入：n = 4
输出：3
解释：F(4) = F(3) + F(2) = 2 + 1 = 3

## 提示

- 0 <= n <= 30

## 解题思路

### 算法分析

这道题是**经典的斐波那契数列问题**，涉及多种优化思路。主要包括：

1. **递归解法**：直接按定义递归，但效率低下
2. **备忘录递归**：记忆化递归，避免重复计算
3. **动态规划**：自底向上构建解
4. **空间优化**：只保存必要的前两项
5. **矩阵快速幂**：O对数级时间复杂度

### 问题本质分析

```mermaid
graph TD
    A[斐波那契数列问题] --> B[递归关系]
    B --> C[递推公式：F_n = F_n-1 + F_n-2]
    B --> D[边界条件：F_0=0, F_1=1]
    
    C --> E[重复子问题]
    E --> F[记忆化优化]
    E --> G[动态规划优化]
    
    F --> H[备忘录递归]
    G --> I[自底向上构建]
    I --> J[空间优化]
```

### 递归问题分析

```mermaid
graph TD
    A[计算F_5] --> B[F_4 + F_3]
    B --> C[F_3 + F_2]
    B --> D[F_2 + F_1]
    
    C --> E[F_2 + F_1]
    C --> F[F_1 + F_0]
    D --> G[F_1 + F_0]
    D --> H[F_1]
    
    E --> I[重复计算F_2]
    F --> J[重复计算F_1]
    G --> I
    H --> J
    
    I --> K[效率问题]
    J --> K
    K --> L[需要优化]
```

### 备忘录递归详解

```mermaid
flowchart TD
    A[开始计算F_n] --> B{检查备忘录}
    B -->|已计算| C[直接返回结果]
    B -->|未计算| D{n小于等于1?}
    
    D -->|是| E[返回基础值]
    D -->|否| F[递归计算F_n-1]
    
    F --> G[递归计算F_n-2]
    G --> H[计算F_n-1加F_n-2]
    H --> I[存入备忘录]
    I --> J[返回结果]
    
    E --> K[存入备忘录]
    K --> J
    C --> J
```

### 备忘录优化原理

```mermaid
graph TD
    A[备忘录优化] --> B[避免重复计算]
    B --> C[哈希表或数组存储]
    C --> D[首次计算时存储]
    D --> E[后续直接查表]
    
    F[时间复杂度] --> G[原始递归：O指数级]
    F --> H[备忘录递归：O线性]
    
    I[空间复杂度] --> J[递归栈：O线性]
    I --> K[备忘录表：O线性]
```

### 动态规划解法

```mermaid
flowchart TD
    A[动态规划解法] --> B[自底向上构建]
    B --> C[初始化dp_0=0和dp_1=1]
    C --> D[循环计算dp_i等于dp_i-1加dp_i-2]
    D --> E[返回dp_n]
    
    F[空间优化版本] --> G[只保存前两个值]
    G --> H[prev1和prev2交替更新]
    H --> I[空间复杂度O常数]
```

### 各种解法对比

```mermaid
graph TD
    A[解法对比] --> B[朴素递归]
    A --> C[备忘录递归]
    A --> D[动态规划]
    A --> E[空间优化DP]
    A --> F[矩阵快速幂]
    
    B --> G[时间O指数级空间O线性]
    C --> H[时间O线性空间O线性]
    D --> I[时间O线性空间O线性]
    E --> J[时间O线性空间O常数]
    F --> K[时间O对数空间O常数]
    
    G --> L[效率最低]
    H --> M[记忆化优化]
    I --> N[经典DP]
    J --> O[最佳平衡]
    K --> P[最高效率]
```

### 代码实现思路

1. **朴素递归法**：
   - 直接按定义实现
   - 存在大量重复计算
   - 时间复杂度指数级

2. **备忘录递归法**：
   - 使用哈希表或数组存储已计算结果
   - 递归时先检查备忘录
   - 时间复杂度降为O(n)

3. **动态规划法**：
   - 自底向上计算
   - 避免递归栈开销
   - 思路清晰易懂

4. **空间优化法**：
   - 只保存前两个状态
   - 空间复杂度O(1)
   - 实际应用推荐

### 时间复杂度分析

- **朴素递归**：O指数级，每个节点分裂成两个子问题
- **备忘录递归**：O线性，每个子问题只计算一次
- **动态规划**：O线性，线性遍历
- **空间优化DP**：O线性，线性遍历
- **矩阵快速幂**：O对数级，快速幂算法

### 空间复杂度分析

- **朴素递归**：O线性，递归栈深度
- **备忘录递归**：O线性，递归栈加备忘录表
- **动态规划**：O线性，DP数组
- **空间优化DP**：O常数，只存储常数个变量
- **矩阵快速幂**：O常数，常数空间

### 备忘录实现细节

```mermaid
graph TD
    A[备忘录实现] --> B[数据结构选择]
    B --> C[数组实现]
    B --> D[哈希表实现]
    
    C --> E[下标直接访问]
    C --> F[空间预分配]
    D --> G[动态扩展]
    D --> H[处理任意输入]
    
    I[初始化策略] --> J[全部初始化为-1]
    I --> K[按需初始化]
    
    E --> L[性能最优]
    F --> L
    G --> M[灵活性好]
    H --> M
```

### 递归树对比

```mermaid
graph TD
    A[原始递归F_5] --> B[F_4]
    A --> C[F_3]
    B --> D[F_3]
    B --> E[F_2]
    C --> F[F_2]
    C --> G[F_1]
    
    H[备忘录递归F_5] --> I[F_4]
    H --> J[F_3已缓存]
    I --> K[F_3]
    I --> L[F_2已缓存]
    J --> M[直接返回]
```

### 实际应用场景

1. **算法竞赛**：经典递推数列问题
2. **系统设计**：缓存策略的典型应用
3. **数学建模**：增长模型和数列计算
4. **性能优化**：记忆化技术的入门案例

### 扩展问题

```mermaid
graph TD
    A[斐波那契扩展] --> B[爬楼梯问题]
    A --> C[第N个丑数]
    A --> D[最小费用爬楼梯]
    A --> E[分割整数]
    
    B --> F[状态转移相同]
    C --> G[动态规划思想]
    D --> H[带权重的DP]
    E --> I[组合数学应用]
    
    F --> J[算法模式复用]
    G --> J
    H --> J
    I --> J
```

### 优化技巧总结

```mermaid
graph TD
    A[优化技巧] --> B[记忆化]
    A --> C[自底向上]
    A --> D[空间压缩]
    A --> E[数学优化]
    
    B --> F[避免重复计算]
    C --> G[避免递归开销]
    D --> H[节省存储空间]
    E --> I[利用数学性质]
    
    F --> J[性能提升策略]
    G --> J
    H --> J
    I --> J
```

### 测试用例设计

```mermaid
graph TD
    A[测试用例] --> B[边界情况]
    A --> C[小规模测试]
    A --> D[性能测试]
    
    B --> E[F_0 = 0]
    B --> F[F_1 = 1]
    C --> G[F_2 到 F_10]
    D --> H[较大的n值]
    
    E --> I[验证算法正确性]
    F --> I
    G --> I
    H --> J[验证性能优化]
```

这个问题的关键在于**理解备忘录的优化原理**和**选择合适的实现方式**，通过避免重复计算大幅提升算法效率，是学习动态规划和记忆化技术的绝佳案例。
