# 127. 单词接龙

## 描述

字典 wordList 中从单词 beginWord 到 endWord 的 转换序列 是一个按下述规格形成的序列 beginWord -> s1 -> s2 -> ... -> sk：

每一对相邻的单词只差一个字母。
 对于 1 <= i <= k 时，每个 si 都在 wordList 中。注意， beginWord 不需要在 wordList 中。
sk == endWord
给你两个单词 beginWord 和 endWord 和一个字典 wordList ，返回 从 beginWord 到 endWord 的 最短转换序列 中的 单词数目 。如果不存在这样的转换序列，返回 0 。

## 示例 1：

输入：beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]
输出：5
解释：一个最短转换序列是 "hit" -> "hot" -> "dot" -> "dog" -> "cog", 返回它的长度 5。

## 示例 2：

输入：beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log"]
输出：0
解释：endWord "cog" 不在字典中，所以无法进行转换。
 
## 提示：

- 1 <= beginWord.length <= 10
- endWord.length == beginWord.length
- 1 <= wordList.length <= 5000
- wordList[i].length == beginWord.length
- beginWord、endWord 和 wordList[i] 由小写英文字母组成
- beginWord != endWord
- wordList 中的所有字符串 互不相同

## 解题思路

### 算法分析

这道题是**图的最短路径**和**BFS广度优先搜索**的经典应用。主要解法包括：

1. **单向BFS**：从起点开始广度优先搜索
2. **双向BFS**：从起点和终点同时搜索
3. **A*搜索**：启发式搜索算法
4. **Dijkstra算法**：适用于加权图的最短路径

### 问题本质分析

```mermaid
graph TD
    A[单词接龙] --> B[图的最短路径问题]
    B --> C[单向BFS]
    B --> D[双向BFS]
    B --> E[A*搜索]
    
    C --> F[从起点层层扩展]
    D --> G[两端同时搜索]
    E --> H[启发式函数引导]
    
    F --> I[时间复杂度O_N²×M]
    G --> J[时间复杂度O_N×M]
    H --> K[时间复杂度优化]
```

### 单向BFS算法详解

```mermaid
flowchart TD
    A[输入beginWord和endWord] --> B[检查endWord是否在wordList中]
    B --> C{endWord存在?}
    C -->|否| D[返回0]
    C -->|是| E[初始化队列和访问集合]
    
    E --> F[将beginWord加入队列]
    F --> G[BFS层次遍历]
    G --> H{队列为空?}
    
    H -->|是| I[返回0 - 无法到达]
    H -->|否| J[取出当前层所有单词]
    
    J --> K[对每个单词尝试变换]
    K --> L[枚举每个位置的26个字母]
    L --> M{新单词在wordList中?}
    
    M -->|否| N[继续下一个变换]
    M -->|是| O{新单词是endWord?}
    
    O -->|是| P[返回当前层数+1]
    O -->|否| Q[加入队列和访问集合]
    
    N --> L
    Q --> L
    L --> R{当前单词所有位置遍历完?}
    R -->|否| L
    R -->|是| S{当前层所有单词处理完?}
    S -->|否| J
    S -->|是| T[层数+1]
    T --> H
```

### 双向BFS算法详解

```mermaid
flowchart TD
    A[双向BFS初始化] --> B[创建正向和反向搜索集合]
    B --> C[beginSet = {beginWord}]
    C --> D[endSet = {endWord}]
    D --> E[visited = 空集合]
    
    E --> F{beginSet和endSet都非空?}
    F -->|否| G[返回0]
    F -->|是| H{beginSet与endSet有交集?}
    
    H -->|是| I[返回当前层数]
    H -->|否| J[选择较小的集合扩展]
    
    J --> K[遍历当前集合中的每个单词]
    K --> L[生成所有可能的邻居]
    L --> M{邻居在对方集合中?}
    
    M -->|是| N[找到连接路径]
    M -->|否| O{邻居未被访问?}
    
    O -->|是| P[加入下一层集合]
    O -->|否| Q[跳过此邻居]
    
    P --> R[标记为已访问]
    Q --> L
    R --> L
    L --> S{当前单词所有邻居处理完?}
    S -->|否| L
    S -->|是| T{当前集合所有单词处理完?}
    T -->|否| K
    T -->|是| U[更新当前集合为下一层]
    U --> V[层数+1]
    V --> F
    
    N --> W[返回总层数]
```

### 邻居单词生成过程

```mermaid
graph TD
    A[邻居单词生成] --> B[遍历单词每个位置]
    B --> C[保存原字符]
    C --> D[尝试26个字母替换]
    D --> E{新单词在字典中?}
    
    E -->|是| F[添加到邻居列表]
    E -->|否| G[跳过此字母]
    
    F --> H[恢复原字符]
    G --> H
    H --> I{所有字母尝试完?}
    I -->|否| D
    I -->|是| J{所有位置处理完?}
    J -->|否| B
    J -->|是| K[返回邻居列表]
```

### 算法流程图

```mermaid
flowchart TD
    A[开始] --> B[输入验证]
    B --> C{endWord在wordList中?}
    C -->|否| D[返回0]
    C -->|是| E[选择搜索算法]
    
    E --> F[单向BFS]
    E --> G[双向BFS]
    
    F --> H[从beginWord开始层次遍历]
    G --> I[从两端同时搜索]
    
    H --> J[生成邻居单词]
    I --> J
    J --> K{找到目标单词?}
    
    K -->|是| L[返回路径长度]
    K -->|否| M{还有未访问单词?}
    
    M -->|是| N[继续搜索下一层]
    M -->|否| O[返回0 - 无路径]
    
    N --> J
```

### 边界情况分析

```mermaid
graph TD
    A[边界情况] --> B[endWord不在字典中]
    A --> C[beginWord等于endWord]
    A --> D[字典为空]
    A --> E[无法到达]
    A --> F[只差一个字母]
    
    B --> G[直接返回0]
    C --> H[返回1或处理特殊情况]
    D --> I[返回0]
    E --> J[BFS遍历完无结果]
    F --> K[返回2]
```

### 各种解法对比

```mermaid
graph TD
    A[解法对比] --> B[单向BFS]
    A --> C[双向BFS]
    A --> D[A*搜索]
    A --> E[DFS回溯]
    
    B --> F[时间O_N²×M空间O_N×M]
    C --> G[时间O_N×M空间O_N×M]
    D --> H[时间优化空间O_N×M]
    E --> I[时间指数级空间O_深度]
    
    F --> J[简单直观推荐]
    G --> K[性能最优推荐]
    H --> L[复杂实现适合研究]
    I --> M[不适合此问题]
```

### 时间复杂度分析

- **单向BFS**：O(N² × M)，N为单词数，M为单词长度
- **双向BFS**：O(N × M)，搜索空间减半
- **A*搜索**：O(N × M × log N)，依赖启发函数
- **DFS回溯**：O(N!)，指数级时间复杂度

### 空间复杂度分析

- **单向BFS**：O(N × M)，队列和访问集合
- **双向BFS**：O(N × M)，两个搜索集合
- **A*搜索**：O(N × M)，优先队列和访问记录
- **DFS回溯**：O(深度 × M)，递归栈空间

### 关键优化点

```mermaid
graph TD
    A[优化策略] --> B[双向搜索]
    A --> C[字典预处理]
    A --> D[邻居缓存]
    A --> E[启发式函数]
    
    B --> F[搜索空间减半]
    C --> G[快速邻居查找]
    D --> H[避免重复计算]
    E --> I[引导搜索方向]
    
    F --> J[性能提升]
    G --> J
    H --> J
    I --> J
```

### 实际应用场景

```mermaid
graph TD
    A[应用场景] --> B[自然语言处理]
    A --> C[游戏开发]
    A --> D[网络路由]
    A --> E[社交网络]
    
    B --> F[词汇语义距离]
    C --> G[路径寻找算法]
    D --> H[最短路径路由]
    E --> I[社交关系链]
    
    F --> J[核心算法组件]
    G --> J
    H --> J
    I --> J
```

### 图构建策略

```mermaid
graph TD
    A[图构建方法] --> B[邻接表]
    A --> C[模式匹配]
    A --> D[在线生成]
    
    B --> E[预构建所有连接]
    C --> F[通配符模式匹配]
    D --> G[动态生成邻居]
    
    E --> H[空间换时间]
    F --> I[中间节点优化]
    G --> J[时间换空间]
```

### 双向BFS优化细节

```mermaid
flowchart TD
    A[双向BFS优化] --> B[始终扩展较小集合]
    B --> C[减少分支因子]
    C --> D[提前终止条件]
    D --> E[内存优化]
    
    A --> F[集合大小比较]
    F --> G[选择扩展方向]
    G --> H[平衡搜索树]
    
    E --> I[及时清理无用节点]
    I --> J[复用数据结构]
```

### 测试用例设计

```mermaid
graph TD
    A[测试用例] --> B[基础功能]
    A --> C[边界情况]
    A --> D[性能测试]
    
    B --> E[正常转换]
    B --> F[单步转换]
    B --> G[多步转换]
    
    C --> H[无法到达]
    C --> I[目标不在字典]
    C --> J[相同起止点]
    
    D --> K[大字典测试]
    D --> L[长单词测试]
    
    E --> M[验证正确性]
    F --> M
    G --> M
    H --> M
    I --> M
    J --> M
    K --> N[验证性能]
    L --> N
```

### 算法扩展

```mermaid
graph TD
    A[算法扩展] --> B[单词接龙II]
    A --> C[最小基因变化]
    A --> D[开锁问题]
    A --> E[迷宫问题]
    
    B --> F[返回所有最短路径]
    C --> G[基因序列变换]
    D --> H[密码锁状态转换]
    E --> I[二维网格路径]
    
    F --> J[图搜索问题家族]
    G --> J
    H --> J
    I --> J
```

### 代码实现要点

1. **图的表示**：
   - 使用邻接表或在线生成邻居
   - 字典可以用Set进行快速查找
   - 考虑内存和时间的平衡

2. **BFS实现细节**：
   - 使用队列进行层次遍历
   - 记录访问状态避免重复
   - 正确处理层数计算

3. **双向BFS优化**：
   - 始终扩展较小的集合
   - 及时检测两个搜索的交集
   - 合理的终止条件

4. **邻居生成策略**：
   - 枚举每个位置的所有可能字符
   - 利用字典进行有效性检查
   - 避免生成已访问的单词

### 手工验证示例

```mermaid
graph TD
    A["hit → cog 示例"] --> B[层次0: hit]
    B --> C[层次1: hot]
    C --> D[层次2: dot, lot]
    D --> E[层次3: dog, log]
    E --> F[层次4: cog]
    
    F --> G[路径长度 = 5]
    
    H[双向BFS] --> I[正向: hit → hot → dot]
    H --> J[反向: cog ← dog ← dot]
    I --> K[在dot处相遇]
    J --> K
    K --> L[总长度 = 3 + 2 = 5]
```

这个问题的关键在于**理解图的最短路径本质**和**掌握BFS层次遍历技巧**，通过合适的搜索策略找到从起始单词到目标单词的最短变换序列。
