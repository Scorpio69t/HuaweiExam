# 95. 不同的二叉搜索树 II

## 题目描述

给你一个整数 n ，请你生成并返回所有由 n 个节点组成且节点值从 1 到 n 互不相同的不同 二叉搜索树 。可以按 任意顺序 返回答案。


## 示例 1：

![uniquebstn3](./images/uniquebstn3.jpg)

输入：n = 3
输出：[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]

## 示例 2：

输入：n = 1
输出：[[1]]


## 提示：

- 1 <= n <= 8

## 解题思路

### 问题分析

这是一道经典的**递归构造二叉搜索树(BST)**问题。与第96题只需要计算数量不同，这道题要求返回所有可能的BST结构。

### 核心思想

利用**分治递归**的思想：
- **选择根节点**：从1到n，每个数字都可以作为根节点
- **递归构造**：以i为根，左子树包含[1...i-1]，右子树包含[i+1...n]
- **笛卡尔积**：左子树的所有可能 × 右子树的所有可能
- **记忆化优化**：缓存已计算的区间结果

### BST性质回顾

**二叉搜索树(Binary Search Tree)**的性质：
1. 左子树所有节点的值 < 根节点的值
2. 右子树所有节点的值 > 根节点的值
3. 左右子树也都是二叉搜索树

### 算法流程图

```mermaid
flowchart TD
    A[开始: generateTrees n] --> B[调用递归函数 start=1, end=n]
    B --> C{start > end?}
    C -->|是| D[返回 null 节点列表]
    C -->|否| E[初始化结果列表 allTrees]
    E --> F{遍历 i from start to end}
    F --> G[递归生成左子树: start to i-1]
    G --> H[递归生成右子树: i+1 to end]
    H --> I{遍历左子树所有可能}
    I --> J{遍历右子树所有可能}
    J --> K[创建新树: root=i, left, right]
    K --> L[添加到 allTrees]
    L --> M{还有组合?}
    M -->|是| I
    M -->|否| N{还有根节点?}
    N -->|是| F
    N -->|否| O[返回 allTrees]
    O --> P[结束]
    
    style A fill:#e1f5fe
    style P fill:#c8e6c9
    style K fill:#fff3e0
```

### 递归构造详解

```mermaid
graph TD
    A[generateTrees 1,3] --> B[选择根节点]
    B --> C[根节点=1]
    B --> D[根节点=2]
    B --> E[根节点=3]
    
    C --> C1[左子树: null]
    C --> C2[右子树: 2,3]
    C2 --> C21[2为根, 右子3]
    C2 --> C22[3为根, 左子2]
    
    D --> D1[左子树: 1]
    D --> D2[右子树: 3]
    D1 --> D11[1种可能]
    D2 --> D22[1种可能]
    
    E --> E1[左子树: 1,2]
    E --> E2[右子树: null]
    E1 --> E11[1为根, 右子2]
    E1 --> E12[2为根, 左子1]
    
    style C fill:#ffcdd2
    style D fill:#c5cae9
    style E fill:#c8e6c9
```

### 记忆化优化策略

```mermaid
graph LR
    A[记忆化优化] --> B[问题重复性]
    A --> C[缓存策略]
    A --> D[空间换时间]
    
    B --> B1[相同区间重复计算]
    B --> B2[start,end 作为键]
    B --> B3[避免冗余递归]
    
    C --> C1[哈希表缓存]
    C --> C2[键: start,end]
    C --> C3[值: 树列表]
    
    D --> D1[空间: O n²×Cn]
    D --> D2[时间: O Cn]
    D --> D3[显著提升性能]
    
    style A fill:#e3f2fd
    style D fill:#c8e6c9
```

### 复杂度分析对比

```mermaid
graph TD
    A[算法复杂度对比] --> B[递归分治]
    A --> C[记忆化递归]
    A --> D[动态规划]
    A --> E[回溯枚举]
    
    B --> B1[时间: O Cn ×n]
    B --> B2[空间: O Cn]
    B --> B3[最直观]
    
    C --> C1[时间: O Cn]
    C --> C2[空间: O n²×Cn]
    C --> C3[最优解法]
    
    D --> D1[时间: O Cn ×n]
    D --> D2[空间: O n²×Cn]
    D --> D3[自底向上]
    
    E --> E1[时间: O Cn ×n²]
    E --> E2[空间: O Cn]
    E → E3[会超时]
    
    style C fill:#4caf50
    style E fill:#f44336
    
    subgraph "说明"
        F[Cn = 第n个卡塔兰数]
        G[Cn = 2n!/n+1!×n!]
        H[C1=1, C2=2, C3=5]
        I[C8=1430]
    end
```

### 笛卡尔积组合图解

以n=3为例，选择根节点2：

```mermaid
graph TB
    A[根节点 2] --> B[左子树: 1]
    A --> C[右子树: 3]
    
    B --> B1[树1: 单节点1]
    C --> C1[树1: 单节点3]
    
    D[组合结果] --> D1[左树1 + 右树1]
    
    B1 -->|×| C1
    B1 -->|=| D1
    
    E[最终树结构]
    E --> E1[根: 2]
    E1 --> E2[左: 1]
    E1 --> E3[右: 3]
    
    style A fill:#ffeb3b
    style D fill:#c8e6c9
```

### 实际构造示例 (n=3)

```mermaid
graph TD
    A[所有可能的BST n=3] --> B[树1: 根1]
    A --> C[树2: 根1]
    A --> D[树3: 根2]
    A --> E[树4: 根3]
    A --> F[树5: 根3]
    
    B --> B1[1]
    B1 --> B2[右: 2]
    B2 --> B3[右: 3]
    
    C --> C1[1]
    C1 --> C2[右: 3]
    C2 --> C3[左: 2]
    
    D --> D1[2]
    D1 --> D2[左: 1]
    D1 --> D3[右: 3]
    
    E --> E1[3]
    E1 --> E2[左: 1]
    E2 --> E3[右: 2]
    
    F --> F1[3]
    F1 --> F2[左: 2]
    F2 --> F3[左: 1]
    
    style D fill:#c8e6c9
```

## 算法实现要点

1. **递归终止条件**：start > end时返回包含null的列表
2. **根节点选择**：遍历start到end，每个值都可作为根
3. **子树构造**：递归生成左右子树的所有可能
4. **笛卡尔积组合**：嵌套循环组合左右子树
5. **节点克隆**：每次创建新的树节点，避免引用问题
6. **记忆化优化**：使用哈希表缓存区间结果
7. **边界处理**：空树、单节点树的特殊情况

## 相关题目

- LeetCode 96. 不同的二叉搜索树（只计算数量）
- LeetCode 108. 将有序数组转换为二叉搜索树
- LeetCode 109. 有序链表转换二叉搜索树
- LeetCode 894. 所有可能的满二叉树
- 卡塔兰数相关问题
