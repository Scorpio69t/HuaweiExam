# 169. 多数元素

## 描述

给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

## 示例 1

输入：nums = [3,2,3]
输出：3

## 示例 2

输入：nums = [2,2,1,1,1,2,2]
输出：2

## 提示

- n == nums.length
- 1 <= n <= 5 * 104
- -10^9 <= nums[i] <= 10^9

## 进阶

尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。

## 解题思路

### 算法分析

这道题是**多数元素查找**的经典问题，核心是找到出现次数大于⌊n/2⌋的元素。主要解法包括：

1. **哈希表统计法**：直接统计每个元素出现次数，简单直观
2. **排序法**：排序后中位数必然是多数元素
3. **摩尔投票法**：最优解，O(n)时间O(1)空间
4. **分治法**：递归思想，分别找左右两部分的多数元素
5. **随机化算法**：随机选择元素验证，期望O(n)时间

### 问题本质分析

```mermaid
graph TD
    A[多数元素问题] --> B[出现次数大于n/2]
    B --> C[必然存在且唯一]
    B --> D[占据数组一半以上]
    
    C --> E[哈希表统计]
    C --> F[排序取中位数]
    D --> G[摩尔投票算法]
    D --> H[分治递归]
    
    E --> I[时间O_n空间O_n]
    F --> J[时间O_nlogn空间O_1]
    G --> K[时间O_n空间O_1最优]
    H --> L[时间O_nlogn空间O_logn]
```

### 摩尔投票算法详解

**核心思想**：多数元素的出现次数大于其他所有元素出现次数之和

```mermaid
flowchart TD
    A[摩尔投票算法] --> B[初始化候选者和计数器]
    B --> C[遍历数组]
    C --> D{计数器是否为0}
    
    D -->|是| E[当前元素成为新候选者]
    D -->|否| F{当前元素等于候选者}
    
    E --> G[计数器设为1]
    F -->|是| H[计数器加1]
    F -->|否| I[计数器减1]
    
    G --> J[继续下一个元素]
    H --> J
    I --> J
    J --> K{遍历完成}
    K -->|否| D
    K -->|是| L[返回候选者]
```

### 摩尔投票算法原理

```mermaid
graph TD
    A[算法原理] --> B[抵消思想]
    B --> C[多数元素vs其他元素]
    C --> D[一对一抵消]
    D --> E[多数元素必然剩余]
    
    B --> F[计数器机制]
    F --> G[相同元素加1]
    F --> H[不同元素减1]
    F --> I[计数器为0时更换候选者]
    
    E --> J[最后剩余的就是多数元素]
    I --> J
```

### 摩尔投票过程示例

```mermaid
flowchart TD
    A[数组2,2,1,1,1,2,2] --> B[初始candidate=null,count=0]
    B --> C[遍历元素2]
    C --> D[count=0,candidate=2,count=1]
    D --> E[遍历元素2]
    E --> F[相同,count=2]
    F --> G[遍历元素1]
    G --> H[不同,count=1]
    H --> I[遍历元素1]
    I --> J[不同,count=0]
    J --> K[遍历元素1]
    K --> L[count=0,candidate=1,count=1]
    L --> M[遍历元素2]
    M --> N[不同,count=0]
    N --> O[遍历元素2]
    O --> P[count=0,candidate=2,count=1]
    P --> Q[结果candidate=2]
```

### 各种解法对比

```mermaid
graph TD
    A[解法对比] --> B[哈希表统计]
    A --> C[排序法]
    A --> D[摩尔投票]
    A --> E[分治法]
    A --> F[随机化]
    
    B --> G[时间O_n空间O_n]
    C --> H[时间O_nlogn空间O_1]
    D --> I[时间O_n空间O_1最优]
    E --> J[时间O_nlogn空间O_logn]
    F --> K[期望O_n空间O_1]
    
    G --> L[直观易懂]
    H --> M[简单可靠]
    I --> N[理论最优推荐]
    J --> O[递归思想]
    K --> P[概率算法]
```

### 算法流程图

```mermaid
flowchart TD
    A[输入数组nums] --> B{选择算法}
    B -->|哈希统计| C[创建哈希表]
    B -->|排序法| D[排序数组]
    B -->|摩尔投票| E[初始化候选者]
    B -->|分治法| F[递归分割]
    
    C --> G[统计每个元素频次]
    G --> H[找到频次大于n/2的元素]
    H --> I[返回结果]
    
    D --> J[取中位数元素]
    J --> I
    
    E --> K[遍历数组投票]
    K --> L[抵消不同元素]
    L --> M[返回最终候选者]
    M --> I
    
    F --> N[分别处理左右部分]
    N --> O[合并左右结果]
    O --> I
```

### 分治算法详解

```mermaid
flowchart TD
    A[分治算法] --> B[分割数组]
    B --> C[递归处理左半部分]
    B --> D[递归处理右半部分]
    
    C --> E[得到左半部分多数元素]
    D --> F[得到右半部分多数元素]
    
    E --> G{左右多数元素相同}
    F --> G
    G -->|是| H[直接返回该元素]
    G -->|否| I[统计两个元素在整个数组中的出现次数]
    I --> J[返回出现次数更多的元素]
    
    H --> K[返回结果]
    J --> K
```

### 代码实现思路

1. **摩尔投票法实现**：
   - 维护候选者和计数器
   - 遍历数组进行投票和抵消
   - 最优的时间空间复杂度

2. **哈希表统计实现**：
   - 使用map统计每个元素出现次数
   - 找到出现次数大于n/2的元素
   - 直观但需要额外空间

3. **排序法实现**：
   - 对数组进行排序
   - 中位数必然是多数元素
   - 简单可靠但时间复杂度较高

4. **分治法实现**：
   - 递归分割数组
   - 合并左右部分的结果
   - 体现分治思想

### 时间复杂度分析

- **哈希表统计法**：O(n)，需要遍历数组一次
- **排序法**：O(n log n)，主要开销在排序
- **摩尔投票法**：O(n)，只需遍历数组一次
- **分治法**：O(n log n)，递归分割加统计
- **随机化算法**：期望O(n)，最坏O(∞)

### 空间复杂度分析

- **哈希表统计法**：O(n)，需要哈希表存储
- **排序法**：O(1)，原地排序
- **摩尔投票法**：O(1)，只需常数额外空间
- **分治法**：O(log n)，递归栈空间
- **随机化算法**：O(1)，只需常数空间

### 关键优化点

1. **摩尔投票核心**：利用多数元素的数量优势
2. **抵消机制**：不同元素相互抵消，多数元素必然剩余
3. **一次遍历**：只需要遍历数组一次
4. **常数空间**：不需要额外的存储空间

### 边界情况处理

1. **数组长度为1**：直接返回唯一元素
2. **所有元素相同**：任意元素都是多数元素
3. **刚好一半以上**：确保找到正确的多数元素
4. **负数元素**：算法对元素值没有限制

### 实际应用场景

1. **投票系统**：找到得票最多的候选人
2. **数据分析**：找到出现频率最高的数据
3. **网络通信**：检测主要的数据模式
4. **质量控制**：识别主要的缺陷类型

### 算法扩展

```mermaid
graph TD
    A[算法扩展] --> B[多数元素II]
    A --> C[前K个高频元素]
    A --> D[数据流中的多数元素]
    A --> E[分布式多数元素]
    
    B --> F[找出现次数大于n/3的元素]
    C --> G[堆排序topK问题]
    D --> H[在线算法设计]
    E --> I[MapReduce思想]
    
    F --> J[摩尔投票算法变种]
    G --> J
    H --> J
    I --> J
```

### 性能优化技巧

```mermaid
graph TD
    A[性能优化] --> B[提前终止]
    A --> C[内存访问优化]
    A --> D[并行化处理]
    A --> E[预处理优化]
    
    B --> F[达到n/2时提前返回]
    C --> G[减少内存分配]
    D --> H[分段并行统计]
    E --> I[预先验证数据特征]
    
    F --> J[实际性能提升]
    G --> J
    H --> J
    I --> J
```

### 测试用例设计

```mermaid
graph TD
    A[测试用例] --> B[基础功能]
    A --> C[边界情况]
    A --> D[性能测试]
    
    B --> E[正常多数元素]
    B --> F[刚好过半]
    C --> G[单元素数组]
    C --> H[全相同元素]
    C --> I[负数元素]
    D --> J[大规模数据]
    D --> K[最坏情况]
    
    E --> L[验证正确性]
    F --> L
    G --> L
    H --> L
    I --> L
    J --> M[验证性能]
    K --> M
```

### 算法正确性证明

**摩尔投票算法正确性**：
1. **不变式**：如果多数元素存在，那么在任何时候被消除的元素中，多数元素的数量不会超过其他元素数量之和
2. **终止性**：算法必然终止，因为数组长度有限
3. **正确性**：由于多数元素数量大于n/2，经过抵消后必然剩余

这个问题的关键在于**理解摩尔投票算法的抵消思想**和**掌握多数元素的数学性质**，通过巧妙的投票机制在O(n)时间O(1)空间内解决问题。
