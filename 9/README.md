# 9. 回文数

## 题目描述

给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。

回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

例如，121 是回文，而 123 不是。

## 示例 1：

输入：x = 121
输出：true

## 示例 2：

输入：x = -121
输出：false
解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。

## 示例 3：

输入：x = 10
输出：false
解释：从右向左读, 为 01 。因此它不是一个回文数。
 

## 提示：

- -2^31 <= x <= 2^31 - 1

## 解题思路

这道题要求判断一个整数是否为回文数。回文数是指正序和倒序读都一样的整数。这是一个数学运算和字符串处理的经典问题。

### 算法分析

这道题的核心思想是**数字反转比较**，主要解法包括：

1. **数学方法**：只反转一半数字进行比较（推荐）
2. **字符串方法**：转换为字符串后使用双指针判断
3. **完全反转法**：反转整个数字后与原数比较
4. **位运算优化**：逐位比较首尾数字

### 问题本质分析

```mermaid
graph TD
    A[回文数判断] --> B[数字特征分析]
    B --> C[符号处理]
    B --> D[位数分析]
    B --> E[数字反转]
    
    C --> F[负数不可能是回文数]
    D --> G[计算数字位数]
    E --> H[反转后半部分]
    
    F --> I[提前返回false]
    G --> J[确定反转范围]
    H --> K[比较前后部分]
    
    I --> L[结果判断]
    J --> L
    K --> L
```

### 数学方法详解

```mermaid
flowchart TD
    A[输入整数x] --> B{是否为负数?}
    B -->|是| C[返回false]
    B -->|否| D{是否为0?}
    
    D -->|是| E[返回true]
    D -->|否| F{是否以0结尾?}
    
    F -->|是| G{是否为0?}
    G -->|是| E
    G -->|否| C
    
    F -->|否| H[开始反转后半部分]
    H --> I[reversed = 0]
    I --> J{x > reversed?}
    
    J -->|否| K{比较结果}
    J -->|是| L[提取最后一位]
    
    L --> M[reversed = reversed*10 + x%10]
    M --> N[x = x/10]
    N --> J
    
    K --> O{x == reversed 或 x == reversed/10?}
    O -->|是| P[返回true]
    O -->|否| Q[返回false]
    
    C --> R[结束]
    E --> R
    P --> R
    Q --> R
```

### 反转过程可视化

```mermaid
graph TD
    A["输入: x = 12321"] --> B[反转过程]
    
    B --> C["初始: x = 12321, reversed = 0"]
    C --> D["第1步: x = 1232, reversed = 1"]
    D --> E["第2步: x = 123, reversed = 12"]
    E --> F["第3步: x = 12, reversed = 123"]
    
    F --> G["x < reversed, 停止反转"]
    G --> H["比较: x = 12, reversed = 123"]
    
    H --> I["奇数长度: x == reversed/10"]
    I --> J["12 == 123/10 = 12 ✓"]
    J --> K["返回true"]
```

### 字符串方法详解

```mermaid
graph TD
    A[字符串方法] --> B[转换为字符串]
    B --> C[双指针初始化]
    C --> D[逐位比较]
    
    B --> E[str = strconv.Itoa(x)]
    C --> F[left = 0, right = len-1]
    D --> G{left < right?}
    
    G -->|否| H[返回true]
    G -->|是| I{str[left] == str[right]?}
    
    I -->|否| J[返回false]
    I -->|是| K[left++, right--]
    
    K --> G
    H --> L[结束]
    J --> L
```

### 各种解法对比

```mermaid
graph TD
    A[解法对比] --> B[数学方法]
    A --> C[字符串方法]
    A --> D[完全反转法]
    A --> E[位运算优化]
    
    B --> F[时间O_log_n空间O_1]
    C --> G[时间O_log_n空间O_log_n]
    D --> H[时间O_log_n空间O_1]
    E --> I[时间O_log_n空间O_1]
    
    B --> J[推荐解法]
    C --> K[直观易懂]
    D --> H[完整反转]
    E --> L[性能最优]
    
    J --> M[空间效率高]
    K --> N[代码简洁]
    H --> O[逻辑清晰]
    L --> P[位运算优化]
    
    M --> Q[适合生产环境]
    N --> Q
    O --> Q
    P --> Q
```

### 算法流程图

```mermaid
flowchart TD
    A[开始] --> B{是否为负数?}
    B -->|是| C[返回false]
    B -->|否| D{是否为0?}
    
    D -->|是| E[返回true]
    D -->|否| F{是否以0结尾?]
    
    F -->|是| G{是否为0?}
    G -->|是| E
    G -->|否| C
    
    F -->|否| H[初始化reversed = 0]
    H --> I{x > reversed?}
    
    I -->|否| J{比较结果}
    I -->|是| K[提取最后一位]
    
    K --> L[reversed = reversed*10 + x%10]
    L --> M[x = x/10]
    M --> I
    
    J --> N{x == reversed 或 x == reversed/10?}
    N -->|是| O[返回true]
    N -->|否| P[返回false]
    
    C --> Q[结束]
    E --> Q
    O --> Q
    P --> Q
```

### 边界情况处理

```mermaid
graph TD
    A[边界情况] --> B[负数]
    A --> C[零值]
    A --> D[单位数]
    A --> E[以0结尾]
    A --> F[溢出检查]
    
    B --> G[直接返回false]
    C --> H[返回true]
    D --> I[返回true]
    E --> J[只有0是回文]
    F --> K[不需要特殊处理]
    
    G --> L[负数不可能是回文]
    H --> L
    I --> L
    J --> L
    K --> L
```

### 时间复杂度分析

```mermaid
graph TD
    A[时间复杂度分析] --> B[数字位数]
    B --> C[反转次数]
    C --> D[总时间复杂度]
    
    B --> E[log₁₀(n)]
    C --> F[O_log_n]
    D --> G[O_log_n]
    
    E --> H[n是整数值]
    F --> I[只反转一半]
    G --> J[最优解法]
```

### 空间复杂度分析

```mermaid
graph TD
    A[空间复杂度分析] --> B[额外空间使用]
    B --> C[局部变量]
    C --> D[常数空间]
    
    D --> E[O_1]
    E --> F[原地算法]
    F --> G[空间效率最优]
```

### 关键优化点

```mermaid
graph TD
    A[优化策略] --> B[只反转一半]
    A --> C[提前返回]
    A --> D[边界条件优化]
    
    B --> E[减少计算量]
    C --> F[避免无效计算]
    D --> G[快速判断]
    
    E --> H[性能提升]
    F --> H
    G --> H
```

### 实际应用场景

```mermaid
graph TD
    A[应用场景] --> B[数字验证]
    A --> C[密码学]
    A --> D[游戏设计]
    A --> E[数学研究]
    
    B --> F[身份证号验证]
    C --> G[数字加密]
    D --> H[数字游戏]
    E --> I[数学性质研究]
    
    F --> J[核心算法组件]
    G --> J
    H --> J
    I --> J
```

### 测试用例设计

```mermaid
graph TD
    A[测试用例] --> B[基础功能]
    A --> C[边界情况]
    A --> D[特殊数字]
    
    B --> E[正数回文]
    B --> F[正数非回文]
    B --> G[负数]
    
    C --> H[0值]
    C --> I[单位数]
    C --> J[以0结尾]
    
    D --> K[不同位数]
    D --> L[对称数字]
    
    E --> M[验证正确性]
    F --> M
    G --> M
    H --> M
    I --> M
    J --> M
    K --> N[验证算法稳定性]
    L --> N
```

### 代码实现要点

1. **负数处理**：
   - 负数不可能是回文数，直接返回false
   - 这是最重要的边界条件

2. **零值处理**：
   - 0是回文数，直接返回true
   - 以0结尾的数字只有0本身是回文数

3. **反转策略**：
   - 只反转后半部分数字
   - 当x ≤ reversed时停止反转

4. **长度判断**：
   - 奇数长度：x == reversed/10
   - 偶数长度：x == reversed

5. **性能优化**：
   - 避免完全反转整个数字
   - 使用数学运算而非字符串操作

这个问题的关键在于**理解只反转一半数字的策略**和**正确处理各种边界情况**，通过巧妙的数学运算实现高效的回文数判断，避免不必要的计算和空间开销。
