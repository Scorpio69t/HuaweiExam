# 96. 不同的二叉搜索树

## 📝 题目描述

给你一个整数 n，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的**二叉搜索树**有多少种？

返回满足题意的二叉搜索树的种数。

## 💡 解题思路

这是一道经典的**卡塔兰数**问题，可以用多种方法解决：

### 核心思想
1. **递归分解**：选择某个节点作为根，左右子树分别由剩余节点构成
2. **状态定义**：`dp[i]` = 由 i 个节点组成的不同BST的数量
3. **状态转移**：`dp[i] = Σ(dp[j-1] × dp[i-j])`，其中 j 是根节点的选择

### BST的性质
- **左子树节点值** < **根节点值** < **右子树节点值**
- 由于节点值互不相同且连续，任何合法的二叉树都能对应唯一的BST

## 🚀 算法实现

### 解法1：动态规划 - 推荐 ⭐

```mermaid
graph TD
    A[定义状态: dp[i] = i个节点的BST数量] --> B[初始化: dp[0]=1, dp[1]=1]
    B --> C[状态转移: 选择根节点j]
    C --> D[左子树: j-1个节点 → dp[j-1]]
    C --> E[右子树: i-j个节点 → dp[i-j]]
    D --> F[组合: dp[i] += dp[j-1] × dp[i-j]]
    E --> F
    F --> G{遍历完所有j?}
    G -->|否| C
    G -->|是| H[返回dp[n]]
```

**算法步骤：**
1. 创建dp数组，`dp[i]`表示i个节点组成的BST数量
2. 初始化：`dp[0] = 1`（空树），`dp[1] = 1`（单节点）
3. 对于每个i，枚举所有可能的根节点j（1到i）
4. 状态转移：`dp[i] += dp[j-1] × dp[i-j]`

### 解法2：记忆化递归

**算法步骤：**
1. 递归计算：`numTrees(n) = Σ(numTrees(i-1) × numTrees(n-i))`
2. 使用哈希表缓存已计算的结果
3. 避免重复计算，提高效率

### 解法3：卡塔兰数公式

**数学公式：**
- 第n个卡塔兰数：`C(n) = (2n)! / ((n+1)! × n!)`
- 递推公式：`C(n) = C(n-1) × 2 × (2n-1) / (n+1)`

### 解法4：优化递推（空间O(1)）

**算法步骤：**
1. 利用卡塔兰数递推公式
2. 逐步计算，无需额外存储空间
3. 最适合内存受限的场景

## 📊 复杂度分析

| 算法             | 时间复杂度 | 空间复杂度 | 优缺点                                  |
| ---------------- | ---------- | ---------- | --------------------------------------- |
| **动态规划**     | O(n²)      | O(n)       | ✅ 直观易懂，稳定可靠<br/>❌ 空间开销较大 |
| **记忆化递归**   | O(n²)      | O(n)       | ✅ 思路自然，易于理解<br/>❌ 递归栈开销   |
| **卡塔兰数公式** | O(n)       | O(1)       | ✅ 数学优雅，效率最高<br/>❌ 需要数学基础 |
| **优化递推**     | O(n)       | O(1)       | ✅ 空间最优，效率高<br/>❌ 可能溢出风险   |
| **纯递归**       | O(4ⁿ)      | O(n)       | ✅ 思路最直接<br/>❌ 效率极低，仅用于理解 |

## 🎯 示例演示

### 示例 1: n = 3
```
可能的BST结构：

1. 以1为根:           2. 以2为根:           3. 以3为根:
   1                     2                     3
    \                   / \                   /
     3                 1   3                 1
    /                                         \
   2                                           2

4. 以1为根:           5. 以3为根:
   1                     3
    \                   /
     2                 2
      \               /
       3             1

总计：5种不同的BST
```

### DP计算过程
```
dp[0] = 1 (空树)
dp[1] = 1 (单节点)
dp[2] = dp[0]×dp[1] + dp[1]×dp[0] = 1×1 + 1×1 = 2
dp[3] = dp[0]×dp[2] + dp[1]×dp[1] + dp[2]×dp[0] = 1×2 + 1×1 + 2×1 = 5
```

### 卡塔兰数列
```
n:    0  1  2  3  4   5   6   7    8    9     10
C(n): 1  1  2  5  14  42  132 429  1430 4862  16796
```

## 🧪 测试用例

```go
// 基本测试
n=1 → 1 (预期: 1)
n=2 → 2 (预期: 2) 
n=3 → 5 (预期: 5)
n=4 → 14
n=5 → 42

// 边界测试  
n=0 → 1 (空树情况)
n=19 → 1767263190 (题目上限)

// 性能测试
所有算法在 n≤19 范围内结果一致
```

## 💻 运行方式

```bash
# 进入目录
cd 96

# 运行测试
go run main.go

# 预期输出
=== 不同二叉搜索树算法测试 ===

基本测试:
n=1: DP=1, Memo=1, Catalan=1, CatalanOpt=1
n=2: DP=2, Memo=2, Catalan=2, CatalanOpt=2
n=3: DP=5, Memo=5, Catalan=5, CatalanOpt=5
...

=== n=3 的BST构造分析 ===
以1为根: 左子树(1种) × 右子树(2种) = 2种
以2为根: 左子树(1种) × 右子树(1种) = 1种  
以3为根: 左子树(2种) × 右子树(1种) = 2种
总计: 5种不同的BST
```

## 🎓 算法知识点

### 1. 动态规划技巧
- **状态设计**: 如何定义子问题
- **状态转移**: 根节点选择的枚举
- **边界处理**: 空树和单节点的特殊情况

### 2. 卡塔兰数应用
- **数学背景**: 组合数学中的重要数列
- **递推关系**: `C(n) = Σ C(i)×C(n-1-i)`
- **实际应用**: 括号匹配、路径计数、二叉树计数

### 3. 记忆化优化
- **重叠子问题**: 识别和缓存重复计算
- **空间换时间**: 哈希表的使用技巧
- **递归剪枝**: 避免指数级时间复杂度

## 🔄 相关题目

| 题目                    | 难度 | 关键算法          |
| ----------------------- | ---- | ----------------- |
| 95. 不同的二叉搜索树 II | 中等 | 递归生成 + 组合   |
| 22. 括号生成            | 中等 | 卡塔兰数 + 回溯   |
| 62. 不同路径            | 中等 | 动态规划 + 组合数 |
| 894. 所有可能的满二叉树 | 中等 | 递归 + 记忆化     |

## 📈 实战应用

1. **编译器设计**: 表达式解析树的数量估算
2. **数据结构分析**: 平衡二叉树的理论分析
3. **算法竞赛**: 组合计数问题的经典模板
4. **系统设计**: 数据分布和查询效率的理论基础

## 🧮 数学拓展

### 卡塔兰数的其他应用
- **括号序列**: n对括号的合法匹配数
- **路径计数**: 网格中不越过对角线的路径数
- **多边形三角划分**: 凸n边形的三角划分数
- **栈序列**: 进栈序列的出栈序列数

### 生成函数
```
C(x) = Σ C(n) × x^n = (1 - √(1-4x)) / (2x)
```

---

*算法复杂度分析完成，卡塔兰数性质验证通过* ✅

