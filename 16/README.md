# 16. 最接近的三数之和

## 题目描述

给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。

返回这三个数的和。

假定每组输入只存在恰好一个解。


## 示例 1：

输入：nums = [-1,2,1,-4], target = 1
输出：2
解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2)。

## 示例 2：

输入：nums = [0,0,0], target = 1
输出：0
解释：与 target 最接近的和是 0（0 + 0 + 0 = 0）。


## 提示：

- 3 <= nums.length <= 1000
- -1000 <= nums[i] <= 1000
- -10^4 <= target <= 10^4

## 解题思路

这道题要求从数组中找出三个数，使它们的和与目标值最接近。这是第15题"三数之和"的变种，需要找到最接近而不是完全相等的组合。这是一个经典的数组搜索和优化问题。

### 算法分析

这道题的核心思想是**排序+双指针优化**，主要解法包括：

1. **排序+双指针法**：先排序，再使用双指针寻找最接近的和（推荐）
2. **优化版本**：添加提前剪枝和重复元素跳过
3. **二分查找法**：固定两个数，用二分查找找第三个数
4. **暴力解法**：三重循环枚举所有可能
5. **递归方法**：使用回溯思想逐步选择

### 问题本质分析

```mermaid
graph TD
    A[最接近的三数之和] --> B[数组排序]
    B --> C[固定第一个数]
    C --> D[双指针寻找]
    D --> E[更新最接近值]
    
    B --> F[时间复杂度优化]
    C --> G[减少搜索空间]
    D --> H[线性时间搜索]
    E --> I[绝对值比较]
    
    F --> J[排序O(n log n)]
    G --> K[跳过重复元素]
    H --> L[双指针O(n)]
    I --> M[距离计算]
    
    J --> N[总体复杂度O(n²)]
    K --> N
    L --> N
    M --> N
```

### 排序+双指针法详解

```mermaid
flowchart TD
    A[输入数组nums和目标值target] --> B[对数组排序]
    B --> C[初始化closestSum和minDiff]
    C --> D[固定第一个数i]
    
    D --> E{i < len(nums)-2?}
    E -->|否| F[返回closestSum]
    E -->|是| G[跳过重复元素]
    
    G --> H[设置双指针left=i+1, right=len(nums)-1]
    H --> I{left < right?}
    
    I -->|否| J[i++]
    J --> D
    
    I -->|是| K[计算sum = nums[i] + nums[left] + nums[right]]
    K --> L[计算diff = abs(sum - target)]
    
    L --> M{diff < minDiff?}
    M -->|是| N[更新minDiff和closestSum]
    M -->|否| O{sum < target?}
    
    N --> O
    O -->|是| P[left++]
    O -->|否| Q{sum > target?}
    O -->|否| R[返回sum]
    
    Q -->|是| S[right--]
    Q -->|否| R
    
    P --> I
    S --> I
    R --> F
```

### 双指针移动策略

```mermaid
graph TD
    A["当前和sum与target比较"] --> B{sum < target?}
    B -->|是| C[left指针右移]
    B -->|否| D{sum > target?}
    B -->|否| E[找到完全相等，直接返回]
    
    D -->|是| F[right指针左移]
    D -->|否| E
    
    C --> G[增大sum值]
    F --> H[减小sum值]
    
    G --> I[接近target]
    H --> I
    I --> J[继续搜索更优解]
    
    E --> K[最优解找到]
```

### 搜索过程可视化

```mermaid
graph TD
    A["输入: nums = [-4, -1, 1, 2], target = 1"] --> B[排序后: [-4, -1, 1, 2]]
    
    B --> C["第1轮: i=0, nums[i]=-4"]
    C --> D["left=1, right=3, sum=-4+(-1)+2=-3"]
    D --> E["diff=|-3-1|=4, 更新closestSum=-3"]
    E --> F["sum < target, left++"]
    
    F --> G["left=2, right=3, sum=-4+1+2=-1"]
    G --> H["diff=|-1-1|=2, 更新closestSum=-1"]
    H --> I["sum < target, left++"]
    
    I --> J["left=3, right=3, 结束第1轮"]
    J --> K["第2轮: i=1, nums[i]=-1"]
    
    K --> L["left=2, right=3, sum=-1+1+2=2"]
    L --> M["diff=|2-1|=1, 更新closestSum=2"]
    M --> N["sum > target, right--"]
    
    N --> O["left=2, right=2, 结束第2轮"]
    O --> P["最终结果: 2"]
```

### 各种解法对比

```mermaid
graph TD
    A[解法对比] --> B[排序+双指针]
    A --> C[优化版本]
    A --> D[二分查找]
    A --> E[暴力解法]
    A --> F[递归方法]
    
    B --> G[时间O_n²空间O_1]
    C --> H[时间O_n²空间O_1]
    D --> I[时间O_n²log_n空间O_1]
    E --> J[时间O_n³空间O_1]
    F --> K[时间O_n³空间O_n]
    
    B --> L[推荐解法]
    C --> M[性能最优]
    D --> N[二分优化]
    E --> O[基础解法]
    F --> P[回溯思想]
    
    L --> Q[平衡性能和可读性]
    M --> Q
    N --> Q
    O --> Q
    P --> Q
```

### 算法流程图

```mermaid
flowchart TD
    A[开始] --> B[对数组排序]
    B --> C[初始化closestSum和minDiff]
    C --> D[i = 0]
    
    D --> E{i < len(nums)-2?}
    E -->|否| F[返回closestSum]
    E -->|是| G{跳过重复元素?}
    
    G -->|是| H[i++]
    H --> D
    
    G -->|否| I[left = i+1, right = len(nums)-1]
    I --> J{left < right?}
    
    J -->|否| K[i++]
    K --> D
    
    J -->|是| L[计算sum和diff]
    L --> M{更新最接近值}
    M --> N{sum与target比较}
    
    N -->|sum < target| O[left++]
    N -->|sum > target| P[right--]
    N -->|sum == target| Q[返回sum]
    
    O --> J
    P --> J
    Q --> R[结束]
```

### 边界情况处理

```mermaid
graph TD
    A[边界情况] --> B[数组长度=3]
    A --> C[重复元素]
    A --> D[负数情况]
    A --> E[目标值超出范围]
    
    B --> F[直接返回三数之和]
    C --> G[跳过重复元素避免重复计算]
    D --> H[正常处理，注意绝对值计算]
    E --> I[仍然能找到最接近值]
    
    F --> J[特殊情况处理]
    G --> J
    H --> J
    I --> J
```

### 时间复杂度分析

```mermaid
graph TD
    A[时间复杂度分析] --> B[排序阶段]
    B --> C[搜索阶段]
    C --> D[总体复杂度]
    
    B --> E[O_n log n]
    C --> F[O_n²]
    D --> G[O_n²]
    
    E --> H[快速排序]
    F --> I[双指针优化]
    G --> J[最优解法]
    J --> K[无法进一步优化]
```

### 空间复杂度分析

```mermaid
graph TD
    A[空间复杂度分析] --> B[额外空间使用]
    B --> C[排序空间]
    C --> D[最终空间复杂度]
    
    B --> E[常数空间]
    C --> F[原地排序O_1]
    D --> G[O_1]
    
    E --> H[只使用局部变量]
    F --> H
    G --> I[空间效率最优]
```

### 关键优化点

```mermaid
graph TD
    A[优化策略] --> B[排序优化]
    A --> C[双指针优化]
    A --> D[剪枝优化]
    
    B --> E[减少搜索空间]
    C --> F[线性时间搜索]
    D --> G[提前返回]
    
    E --> H[跳过重复元素]
    F --> H
    G --> H
```

### 实际应用场景

```mermaid
graph TD
    A[应用场景] --> B[数值逼近]
    A --> C[优化问题]
    A --> D[机器学习]
    A --> E[金融计算]
    
    B --> F[函数逼近]
    C --> G[资源分配优化]
    D --> H[参数调优]
    E --> I[投资组合优化]
    
    F --> J[核心算法组件]
    G --> J
    H --> J
    I --> J
```

### 测试用例设计

```mermaid
graph TD
    A[测试用例] --> B[基础功能]
    A --> C[边界情况]
    A --> D[特殊情况]
    
    B --> E[正常数组]
    B --> F[有重复元素]
    B --> G[负数数组]
    
    C --> H[最小长度数组]
    C --> I[最大长度数组]
    C --> J[极值目标]
    
    D --> K[完全相等]
    D --> L[接近但不相等]
    D --> M[所有元素相同]
    
    E --> N[验证正确性]
    F --> N
    G --> N
    H --> N
    I --> N
    J --> N
    K --> O[验证特殊情况]
    L --> O
    M --> O
```

### 代码实现要点

1. **排序策略**：
   - 先对数组排序，便于双指针操作
   - 排序后可以跳过重复元素

2. **双指针优化**：
   - 固定第一个数，用双指针寻找另外两个数
   - 根据sum与target的关系移动指针

3. **距离计算**：
   - 使用绝对值计算距离
   - 实时更新最接近的和

4. **剪枝优化**：
   - 跳过重复元素避免重复计算
   - 找到完全相等时提前返回

5. **边界处理**：
   - 处理数组长度为3的特殊情况
   - 确保所有边界条件都有正确输出

这个问题的关键在于**理解双指针的移动策略**和**掌握距离计算的优化方法**，通过排序和双指针技术，将时间复杂度从O(n³)优化到O(n²)，实现高效的最接近三数之和查找。特别是双指针的移动逻辑，需要根据当前和与目标值的关系来决定移动方向。
