# 213. 打家劫舍 II - 测试用例

## 基础测试用例
输入: [2,3,2]
输出: 3
说明: 房屋呈环形，第一间和最后一间相邻。可以偷第二间(3)或者偷任意一间值为2的房屋。

输入: [1,2,3,1]
输出: 4
说明: 可以偷第一间(1)和第三间(3)，总金额为4。

输入: [1,2,3]
输出: 3
说明: 偷第三间房屋获得最大金额3。

## 边界测试用例
输入: [5]
输出: 5
说明: 只有一间房屋。

输入: [1,2]
输出: 2
说明: 两间房屋，选择金额更大的。

输入: [2,1]
输出: 2
说明: 两间房屋，选择金额更大的。

## 极值测试用例
输入: [1,1,1,1]
输出: 2
说明: 在环形约束下，最多只能偷两间不相邻的房屋。

输入: [1000,1,1,1000]
输出: 1001
说明: 环形约束下，第一间和最后一间不能同时偷，最优解为1000+1=1001。

输入: [0,0,0]
输出: 0
说明: 所有房屋都没有金额。

## 特殊模式测试
输入: [1,2,3,4,5]
输出: 8
说明: 环形约束下，不能同时选择第一间和最后一间。最优解为2+4+2=8或3+5=8。

输入: [5,4,3,2,1]
输出: 8
说明: 选择房屋5,3，总金额为5+3=8。

输入: [100,1,100,1,100]
输出: 200
说明: 环形约束下，不能同时选择第一间和最后一间的100，最优解为选择中间的两个100。

输入: [1,5,1,5,1]
输出: 10
说明: 选择两个值为5的房屋，总金额为10。

## 算法验证点

### 环形约束验证
- 第一间和最后一间房屋相邻
- 需要分为两种情况讨论：
  1. 包含第一间，排除最后一间
  2. 排除第一间，包含最后一间

### 动态规划状态转移
- dp[i] = max(dp[i-1], dp[i-2] + nums[i])
- 表示前i间房屋能偷到的最大金额

### 空间优化可行性
- 状态转移只依赖前两个状态
- 可以用O(1)空间代替O(n)空间

### 记忆化递归正确性
- 避免重复计算子问题
- 时间复杂度从指数级降到线性

### 边界条件处理
- n=1: 直接返回nums[0]
- n=2: 返回max(nums[0], nums[1])
- n≥3: 应用环形分解策略 