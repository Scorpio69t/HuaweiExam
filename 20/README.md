# 20. 有效的括号

## 描述

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

有效字符串需满足：

左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
每个右括号都有一个对应的相同类型的左括号。

## 示例 1

输入：s = "()"

输出：true

## 示例 2

输入：s = "()[]{}"

输出：true

## 示例 3

输入：s = "(]"

输出：false

## 示例 4

输入：s = "([])"

输出：true

## 示例 5

输入：s = "([)]"

输出：false

## 提示

1 <= s.length <= 104
s 仅由括号 '()[]{}' 组成

## 解题思路

### 算法分析

这道题是**栈数据结构**的经典应用。主要解法包括：

1. **栈匹配法**：使用栈存储左括号，遇到右括号时匹配栈顶
2. **计数器法**：分别计数三种括号的开闭状态
3. **替换法**：不断替换匹配的括号对直到无法替换

### 问题本质分析

```mermaid
graph TD
    A[有效的括号] --> B[括号匹配问题]
    B --> C[栈匹配策略]
    B --> D[计数策略]
    B --> E[替换策略]
    
    C --> F[栈存储左括号]
    D --> G[三个计数器]
    E --> H[字符串替换]
    
    F --> I[时间复杂度O_n空间复杂度O_n]
    G --> J[时间复杂度O_n空间复杂度O_1]
    H --> K[时间复杂度O_n²空间复杂度O_n]
```

### 栈匹配算法详解

```mermaid
flowchart TD
    A[输入字符串s] --> B[初始化空栈]
    B --> C[遍历字符串]
    C --> D{当前字符类型}
    
    D -->|左括号| E[压入栈中]
    D -->|右括号| F{栈是否为空}
    
    E --> G[继续下一字符]
    F -->|空| H[返回false]
    F -->|非空| I[取栈顶元素]
    
    I --> J{括号是否匹配}
    J -->|匹配| K[弹出栈顶]
    J -->|不匹配| H
    
    K --> G
    G --> L{是否遍历完成}
    L -->|否| D
    L -->|是| M{栈是否为空}
    M -->|空| N[返回true]
    M -->|非空| H
```

### 括号匹配过程演示

```mermaid
graph TD
    A["输入: '([{}])'"] --> B[遍历过程]
    B --> C["'(' → 栈: ['(']"]
    C --> D["'[' → 栈: ['(', '[']"]
    D --> E["'{' → 栈: ['(', '[', '{']"]
    E --> F["'}' → 匹配'{' → 栈: ['(', '[']"]
    F --> G["']' → 匹配'[' → 栈: ['(']"]
    G --> H["')' → 匹配'(' → 栈: []"]
    H --> I[栈为空，返回true]
```

### 不匹配情况分析

```mermaid
graph TD
    A[不匹配情况] --> B[类型不匹配]
    A --> C[数量不匹配]
    A --> D[顺序不匹配]
    
    B --> E["'(' 与 ']' 不匹配"]
    C --> F["左括号多：'((('"]
    C --> G["右括号多：')))'"]
    D --> H["交叉嵌套：'([)]'"]
    
    E --> I[返回false]
    F --> I
    G --> I
    H --> I
```

### 算法流程图

```mermaid
flowchart TD
    A[开始] --> B[初始化栈]
    B --> C[获取下一个字符]
    C --> D{字符是左括号?}
    
    D -->|是| E[压入栈]
    D -->|否| F{字符是右括号?}
    
    F -->|是| G{栈为空?}
    F -->|否| C
    
    G -->|是| H[返回false]
    G -->|否| I[获取栈顶元素]
    
    I --> J{括号匹配?}
    J -->|是| K[弹出栈顶]
    J -->|否| H
    
    E --> L{还有字符?}
    K --> L
    L -->|是| C
    L -->|否| M{栈为空?}
    
    M -->|是| N[返回true]
    M -->|否| H
```

### 各种解法对比

```mermaid
graph TD
    A[解法对比] --> B[栈匹配法]
    A --> C[计数器法]
    A --> D[替换法]
    A --> E[递归法]
    
    B --> F[时间O_n空间O_n]
    C --> G[时间O_n空间O_1]
    D --> H[时间O_n²空间O_n]
    E --> I[时间O_n空间O_n]
    
    F --> J[经典解法推荐]
    G --> K[空间优化仅限简单情况]
    H --> L[效率较低不推荐]
    I --> M[代码简洁但栈深度风险]
```

### 栈操作示意图

```mermaid
graph TD
    A[栈操作过程] --> B[遇到左括号]
    A --> C[遇到右括号]
    
    B --> D[PUSH操作]
    C --> E{栈空检查}
    
    D --> F[栈顶增加元素]
    E -->|空| G[直接返回false]
    E -->|非空| H[POP操作]
    
    H --> I{类型匹配检查}
    I -->|匹配| J[弹出栈顶元素]
    I -->|不匹配| G
    
    F --> K[继续处理下一字符]
    J --> K
```

### 边界情况处理

```mermaid
graph TD
    A[边界情况] --> B[空字符串]
    A --> C[单个字符]
    A --> D[只有左括号]
    A --> E[只有右括号]
    A --> F[最大长度]
    
    B --> G[返回true]
    C --> H[单个字符必定false]
    D --> I[栈非空返回false]
    E --> J[栈空时遇右括号返回false]
    F --> K[正常处理无特殊逻辑]
```

### 时间复杂度分析

- **栈匹配法**：O(n)，每个字符访问一次
- **计数器法**：O(n)，但只适用于单一类型括号
- **替换法**：O(n²)，需要多次遍历字符串
- **递归法**：O(n)，但有栈溢出风险

### 空间复杂度分析

- **栈匹配法**：O(n)，最坏情况栈存储n/2个左括号
- **计数器法**：O(1)，只需要常数个计数器
- **替换法**：O(n)，需要创建新字符串
- **递归法**：O(n)，递归调用栈空间

### 关键优化点

```mermaid
graph TD
    A[优化策略] --> B[提前终止]
    A --> C[字符映射]
    A --> D[栈容量预分配]
    A --> E[字符数组优化]
    
    B --> F[奇数长度直接返回false]
    C --> G[使用map快速匹配]
    D --> H[避免栈动态扩容]
    E --> I[避免字符串操作开销]
    
    F --> J[性能提升]
    G --> J
    H --> J
    I --> J
```

### 实际应用场景

```mermaid
graph TD
    A[应用场景] --> B[编译器设计]
    A --> C[文本编辑器]
    A --> D[表达式解析]
    A --> E[XML/HTML解析]
    
    B --> F[语法分析器]
    C --> G[括号匹配高亮]
    D --> H[数学表达式求值]
    E --> I[标签匹配验证]
    
    F --> J[核心算法组件]
    G --> J
    H --> J
    I --> J
```

### 测试用例设计

```mermaid
graph TD
    A[测试用例] --> B[基础功能]
    A --> C[边界情况]
    A --> D[性能测试]
    
    B --> E[简单匹配]
    B --> F[复杂嵌套]
    B --> G[混合括号]
    
    C --> H[空字符串]
    C --> I[单字符]
    C --> J[不匹配情况]
    
    D --> K[最大长度]
    D --> L[大量嵌套]
    
    E --> M[验证正确性]
    F --> M
    G --> M
    H --> M
    I --> M
    J --> M
    K --> N[验证性能]
    L --> N
```

### 代码实现要点

1. **栈数据结构选择**：
   - Go语言使用切片模拟栈
   - 入栈操作：append()
   - 出栈操作：切片截取

2. **括号匹配映射**：
   - 使用map存储括号对应关系
   - 快速查找匹配的左括号

3. **边界条件处理**：
   - 字符串长度为奇数直接返回false
   - 栈为空时遇到右括号返回false
   - 遍历结束后检查栈是否为空

4. **性能优化**：
   - 提前返回减少不必要计算
   - 使用局部变量减少重复计算
   - 合理的数据结构选择

这个问题的关键在于**理解栈的后进先出特性**和**掌握括号匹配的基本规则**，通过栈来暂存待匹配的左括号，实现高效的括号有效性检查。

