# 337. 打家劫舍 III

## 题目描述

小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 root 。

除了 root 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 两个直接相连的房子在同一天晚上被打劫 ，房屋将自动报警。

给定二叉树的 root 。返回 在不触动警报的情况下 ，小偷能够盗取的最高金额 。


## 示例 1:

![rob1](./images/rob1-tree.jpg)

输入: root = [3,2,3,null,3,null,1]
输出: 7 
解释: 小偷一晚能够盗取的最高金额 3 + 3 + 1 = 7


## 示例 2:

![rob2](./images/rob2-tree.jpg)

输入: root = [3,4,5,1,3,null,1]
输出: 9
解释: 小偷一晚能够盗取的最高金额 4 + 5 = 9

## 提示：

- 树的节点数在 [1, 10^4] 范围内
- 0 <= Node.val <= 10^4

## 解题思路

这是一道经典的**树形动态规划**问题，需要在二叉树上进行状态转移。核心思想是对于每个节点，我们需要考虑**偷**或**不偷**两种状态，并选择收益最大的方案。

### 核心思路

1. **状态定义**：对于每个节点，定义两种状态
   - `rob[0]`：不偷当前节点能获得的最大金额
   - `rob[1]`：偷当前节点能获得的最大金额

2. **状态转移**：
   - 不偷当前节点：可以偷或不偷子节点，取最大值
   - 偷当前节点：不能偷子节点，只能取子节点的不偷状态

3. **递归关系**：
   - `dp[node][0] = max(dp[left][0], dp[left][1]) + max(dp[right][0], dp[right][1])`
   - `dp[node][1] = node.val + dp[left][0] + dp[right][0]`

### 算法流程图

```mermaid
graph TD
    A[开始] --> B[判断节点是否为空]
    B -->|是| C[返回 [0,0]]
    B -->|否| D[递归计算左子树状态]
    D --> E[递归计算右子树状态]
    E --> F[计算不偷当前节点的最大值]
    F --> G[计算偷当前节点的最大值]
    G --> H[返回两种状态的数组]
    H --> I[取两种状态的最大值]
    I --> J[结束]
```

### 状态转移详解

```mermaid
graph TD
    A[当前节点] --> B{偷当前节点?}
    B -->|不偷| C[左子节点可偷可不偷]
    B -->|偷| D[左右子节点都不能偷]
    C --> E[max(left[0], left[1])]
    C --> F[max(right[0], right[1])]
    D --> G[left[0] + right[0]]
    E --> H[不偷状态: left_max + right_max]
    F --> H
    G --> I[偷状态: node.val + left[0] + right[0]]
    H --> J[返回 [不偷, 偷]]
    I --> J
```

### 记忆化优化策略

```mermaid
graph TD
    A[记忆化优化] --> B[使用HashMap缓存]
    B --> C[节点地址作为key]
    C --> D[状态数组作为value]
    D --> E[避免重复计算]
    E --> F[时间复杂度O(N)]
    F --> G[空间复杂度O(N)]
```

### 三种解法对比

```mermaid
graph TD
    A[解法选择] --> B[暴力递归]
    A --> C[记忆化递归]
    A --> D[树形DP]
    
    B --> E[时间复杂度: O(2^N)]
    B --> F[空间复杂度: O(H)]
    B --> G[会超时]
    
    C --> H[时间复杂度: O(N)]
    C --> I[空间复杂度: O(N)]
    C --> J[使用HashMap缓存]
    
    D --> K[时间复杂度: O(N)]
    D --> L[空间复杂度: O(H)]
    D --> M[最优解法]
```

### 复杂度分析

- **时间复杂度**: O(N) - 每个节点访问一次
- **空间复杂度**: O(H) - 递归栈深度，H为树的高度

## 算法实现要点

1. **二叉树遍历**：使用后序遍历，先处理子节点再处理父节点
2. **状态管理**：每个节点返回包含两种状态的数组`[不偷, 偷]`
3. **边界处理**：空节点返回`[0, 0]`
4. **最优选择**：根节点取两种状态的最大值

```
