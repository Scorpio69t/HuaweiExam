# 34. 在排序数组中查找元素的第一个和最后一个位置

## 描述

给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 target，返回 [-1, -1]。

你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。

 
## 示例 1：

输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]

## 示例 2：

输入：nums = [5,7,7,8,8,10], target = 6
输出：[-1,-1]

## 示例 3：

输入：nums = [], target = 0
输出：[-1,-1]
 
## 提示：

- 0 <= nums.length <= 105
- -10^9 <= nums[i] <= 10^9
- nums 是一个非递减数组
- -10^9 <= target <= 10^9

## 解题思路

### 算法分析

这道题是**二分查找**和**边界查找**的经典应用。主要解法包括：

1. **双重二分查找法**：分别查找左边界和右边界
2. **单次二分查找法**：一次查找确定范围
3. **线性查找法**：暴力遍历（不满足时间复杂度要求）
4. **库函数法**：使用内置的查找函数

### 问题本质分析

```mermaid
graph TD
    A[排序数组范围查找] --> B[二分查找变种]
    B --> C[左边界查找]
    B --> D[右边界查找]
    B --> E[范围确定]
    
    C --> F[找到第一个>=target的位置]
    D --> G[找到最后一个<=target的位置]
    E --> H[合并两个边界结果]
    
    F --> I[时间复杂度O_logn]
    G --> I
    H --> I
```

### 双重二分查找详解

```mermaid
flowchart TD
    A[输入nums和target] --> B[查找左边界]
    B --> C[left_bound = findLeft]
    C --> D{左边界是否存在}
    
    D -->|不存在| E[返回[-1,-1]]
    D -->|存在| F[查找右边界]
    F --> G[right_bound = findRight]
    
    G --> H[返回[left_bound, right_bound]]
    
    B --> I[左边界二分查找]
    I --> J[寻找第一个>=target的位置]
    
    F --> K[右边界二分查找]
    K --> L[寻找最后一个<=target的位置]
```

### 左边界查找过程

```mermaid
flowchart TD
    A[左边界查找] --> B[初始化left=0, right=len]
    B --> C{left < right}
    C -->|否| D[返回left]
    C -->|是| E[计算mid = left + (right-left)/2]
    
    E --> F{nums[mid] < target}
    F -->|是| G[left = mid + 1]
    F -->|否| H[right = mid]
    
    G --> C
    H --> C
    D --> I[检查边界有效性]
```

### 右边界查找过程

```mermaid
flowchart TD
    A[右边界查找] --> B[初始化left=0, right=len]
    B --> C{left < right}
    C -->|否| D[返回left-1]
    C -->|是| E[计算mid = left + (right-left)/2]
    
    E --> F{nums[mid] <= target}
    F -->|是| G[left = mid + 1]
    F -->|否| H[right = mid]
    
    G --> C
    H --> C
    D --> I[检查边界有效性]
```

### 算法流程图

```mermaid
flowchart TD
    A[开始] --> B[输入验证]
    B --> C{数组为空}
    C -->|是| D[返回[-1,-1]]
    C -->|否| E[查找左边界]
    
    E --> F[二分查找第一个>=target]
    F --> G{找到有效位置}
    G -->|否| D
    G -->|是| H{nums[left]==target}
    
    H -->|否| D
    H -->|是| I[查找右边界]
    I --> J[二分查找最后一个<=target]
    J --> K[返回[left, right]]
```

### 边界情况分析

```mermaid
graph TD
    A[边界情况] --> B[空数组]
    A --> C[单元素数组]
    A --> D[目标不存在]
    A --> E[全部相同元素]
    A --> F[目标在首尾]
    
    B --> G[直接返回[-1,-1]]
    C --> H[判断唯一元素是否匹配]
    D --> I[两次二分都找不到]
    E --> J[返回[0, n-1]]
    F --> K[边界处理要准确]
```

### 各种解法对比

```mermaid
graph TD
    A[解法对比] --> B[双重二分查找]
    A --> C[单次二分查找]
    A --> D[线性查找]
    A --> E[库函数法]
    
    B --> F[时间O_logn空间O_1]
    C --> G[时间O_logn空间O_1]
    D --> H[时间O_n空间O_1]
    E --> I[时间O_logn空间O_1]
    
    F --> J[推荐解法清晰易懂]
    G --> K[代码紧凑但复杂]
    H --> L[不满足题目要求]
    I --> M[语言特定实现]
```

### 二分查找变种详解

```mermaid
graph TD
    A[二分查找变种] --> B[查找确切值]
    A --> C[查找左边界]
    A --> D[查找右边界]
    A --> E[查找插入位置]
    
    B --> F[nums[mid] == target时直接返回]
    C --> G[nums[mid] >= target时收缩右边界]
    D --> H[nums[mid] <= target时收缩左边界]
    E --> I[找到第一个>target的位置]
    
    F --> J[经典二分查找]
    G --> K[左边界二分]
    H --> L[右边界二分]
    I --> M[插入位置二分]
```

### 时间复杂度分析

- **双重二分查找**：O(log n)，执行两次独立的二分查找
- **单次二分查找**：O(log n)，一次遍历确定范围
- **线性查找**：O(n)，不满足题目要求
- **库函数查找**：O(log n)，依赖具体实现

### 空间复杂度分析

- **双重二分查找**：O(1)，只使用常数额外空间
- **单次二分查找**：O(1)，只使用常数额外空间
- **线性查找**：O(1)，只使用常数额外空间
- **库函数查找**：O(1)，通常只使用常数空间

### 关键优化点

```mermaid
graph TD
    A[优化策略] --> B[边界处理]
    A --> C[提前退出]
    A --> D[溢出防护]
    A --> E[代码复用]
    
    B --> F[准确定义开闭区间]
    C --> G[空数组直接返回]
    D --> H[mid计算防止溢出]
    E --> I[统一二分查找模板]
    
    F --> J[避免边界错误]
    G --> J
    H --> J
    I --> J
```

### 实际应用场景

```mermaid
graph TD
    A[应用场景] --> B[数据库索引]
    A --> C[搜索引擎]
    A --> D[数据分析]
    A --> E[算法竞赛]
    
    B --> F[范围查询优化]
    C --> G[相关性排序查找]
    D --> H[时间序列数据范围]
    E --> I[区间查找问题]
    
    F --> J[核心算法组件]
    G --> J
    H --> J
    I --> J
```

### 二分查找模板

```mermaid
flowchart TD
    A[二分查找模板选择] --> B[左闭右闭 [left, right]]
    A --> C[左闭右开 [left, right)]
    A --> D[左开右开 (left, right)]
    
    B --> E[right = len - 1]
    C --> F[right = len]
    D --> G[left = -1, right = len]
    
    E --> H[while left <= right]
    F --> I[while left < right]
    G --> I
    
    H --> J[经典二分模板]
    I --> K[边界查找模板]
```

### 算法扩展

```mermaid
graph TD
    A[算法扩展] --> B[查找峰值]
    A --> C[旋转数组查找]
    A --> D[二维矩阵查找]
    A --> E[第K小元素]
    
    B --> F[山峰数组问题]
    C --> G[分治策略]
    D --> H[行列有序矩阵]
    E --> I[快速选择算法]
    
    F --> J[二分查找家族]
    G --> J
    H --> J
    I --> J
```

### 测试用例设计

```mermaid
graph TD
    A[测试用例] --> B[基础功能]
    A --> C[边界情况]
    A --> D[性能测试]
    
    B --> E[目标存在]
    B --> F[目标不存在]
    B --> G[重复元素]
    
    C --> H[空数组]
    C --> I[单元素]
    C --> J[全相同]
    
    D --> K[大数组]
    D --> L[最坏情况]
    
    E --> M[验证正确性]
    F --> M
    G --> M
    H --> M
    I --> M
    J --> M
    K --> N[验证性能]
    L --> N
```

### 常见错误避免

```mermaid
graph TD
    A[常见错误] --> B[边界计算错误]
    A --> C[无限循环]
    A --> D[整数溢出]
    A --> E[边界条件遗漏]
    
    B --> F[左右边界定义不一致]
    C --> G[left和right更新错误]
    D --> H[mid计算溢出]
    E --> I[特殊情况未处理]
    
    F --> J[使用统一模板]
    G --> K[保证循环收敛]
    H --> L[使用安全计算]
    I --> M[完善测试用例]
```

### 代码实现要点

1. **二分查找模板**：
   - 使用左闭右开区间避免边界错误
   - mid计算使用`left + (right-left)/2`防溢出
   - 明确left和right的更新规则

2. **边界查找逻辑**：
   - 左边界：找第一个大于等于target的位置
   - 右边界：找最后一个小于等于target的位置
   - 验证找到的位置是否有效

3. **特殊情况处理**：
   - 空数组直接返回[-1,-1]
   - 目标值不存在返回[-1,-1]
   - 单元素数组的边界情况

4. **性能优化技巧**：
   - 提前判断边界情况
   - 使用位运算优化除法
   - 减少重复的边界检查

### 手工验证示例

```mermaid
graph TD
    A["数组[5,7,7,8,8,10], target=8"] --> B[查找左边界]
    B --> C["left=0, right=6"]
    C --> D["mid=3, nums[3]=8 >= 8, right=3"]
    D --> E["mid=1, nums[1]=7 < 8, left=2"]
    E --> F["mid=2, nums[2]=7 < 8, left=3"]
    F --> G["left=right=3, 左边界=3"]
    
    G --> H[查找右边界]
    H --> I["left=0, right=6"]
    I --> J["mid=3, nums[3]=8 <= 8, left=4"]
    J --> K["mid=5, nums[5]=10 > 8, right=5"]
    K --> L["mid=4, nums[4]=8 <= 8, left=5"]
    L --> M["left=right=5, 右边界=4"]
    
    M --> N["返回[3,4]"]
```

这个问题的关键在于**理解二分查找的边界处理**和**掌握左右边界的查找技巧**，通过两次二分查找分别确定目标值的起始和结束位置。

