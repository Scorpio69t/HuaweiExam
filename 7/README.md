# 7. 整数反转

## 题目描述

给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。

如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。

假设环境不允许存储 64 位整数（有符号或无符号）。

## 示例 1：

输入：x = 123
输出：321

## 示例 2：

输入：x = -123
输出：-321

## 示例 3：

输入：x = 120
输出：21

## 示例 4：

输入：x = 0
输出：0


## 提示：

- -2^31 <= x <= 2^31 - 1

## 解题思路

这道题要求将整数的数字部分反转，同时需要处理溢出问题。这是一个数学运算和边界处理的经典问题。

### 算法分析

这道题的核心思想是**逐位提取并重组**，主要解法包括：

1. **数学方法**：使用取模和除法逐位提取数字
2. **字符串方法**：转换为字符串后反转
3. **位运算优化**：使用位运算优化溢出检查
4. **溢出处理**：在计算过程中检查32位整数范围

### 问题本质分析

```mermaid
graph TD
    A[整数反转] --> B[数字位提取]
    B --> C[位序重排]
    C --> D[结果重组]
    
    B --> E[取模运算获取个位]
    B --> F[除法运算去掉个位]
    C --> G[从右到左重新组合]
    D --> H[检查溢出范围]
    
    E --> I[digit = x % 10]
    F --> J[x = x / 10]
    G --> K[result = result * 10 + digit]
    H --> L[返回结果或0]
    
    I --> M[循环处理]
    J --> M
    K --> M
    M --> N[直到x为0]
```

### 数学方法详解

```mermaid
flowchart TD
    A[输入整数x] --> B{是否为负数?}
    B -->|是| C[记录负号并转为正数]
    B -->|否| D[直接处理]
    
    C --> E[初始化result = 0]
    D --> E
    
    E --> F{x > 0?}
    F -->|否| G[返回结果]
    F -->|是| H[提取个位数字]
    
    H --> I[digit = x % 10]
    I --> J[检查溢出]
    J --> K{会溢出?}
    
    K -->|是| L[返回0]
    K -->|否| M[更新结果]
    
    M --> N[result = result * 10 + digit]
    N --> O[x = x / 10]
    O --> F
    
    G --> P{原数为负数?}
    P -->|是| Q[返回-result]
    P -->|否| R[返回result]
    
    L --> S[结束]
    Q --> S
    R --> S
```

### 溢出检查策略

```mermaid
graph TD
    A[溢出检查策略] --> B[乘法前检查]
    B --> C[除法优化]
    C --> D[边界值处理]
    
    B --> E[result > MaxInt32/10]
    B --> F[result == MaxInt32/10 && digit > 7]
    B --> G[result < MinInt32/10]
    B --> H[result == MinInt32/10 && digit < -8]
    
    E --> I[返回0]
    F --> I
    G --> I
    H --> I
    
    C --> J[避免直接乘法]
    D --> K[处理边界情况]
    
    J --> L[提高安全性]
    K --> L
```

### 反转过程可视化

```mermaid
graph TD
    A["输入: x = 123"] --> B[反转过程]
    
    B --> C["第1步: digit = 123 % 10 = 3"]
    C --> D["result = 0 * 10 + 3 = 3"]
    D --> E["x = 123 / 10 = 12"]
    
    E --> F["第2步: digit = 12 % 10 = 2"]
    F --> G["result = 3 * 10 + 2 = 32"]
    G --> H["x = 12 / 10 = 1"]
    
    H --> I["第3步: digit = 1 % 10 = 1"]
    I --> J["result = 32 * 10 + 1 = 321"]
    J --> K["x = 1 / 10 = 0"]
    
    K --> L["x = 0, 循环结束"]
    L --> M["输出: 321"]
```

### 负数处理策略

```mermaid
graph TD
    A[负数处理] --> B[检测符号]
    B --> C[转为正数]
    C --> D[按正数处理]
    D --> E[恢复符号]
    
    B --> F[isNegative = x < 0]
    C --> G[x = -x]
    D --> H[逐位提取反转]
    E --> I[return -result]
    
    F --> J[符号标记]
    G --> K[绝对值处理]
    H --> L[统一算法]
    I --> M[最终结果]
```

### 各种解法对比

```mermaid
graph TD
    A[解法对比] --> B[数学方法]
    A --> C[字符串方法]
    A --> D[位运算优化]
    
    B --> E[时间O_log_n空间O_1]
    C --> F[时间O_log_n空间O_log_n]
    D --> G[时间O_log_n空间O_1]
    
    E --> H[推荐解法]
    F --> I[直观易懂]
    G --> J[性能最优]
    
    H --> K[空间效率高]
    I --> L[代码简洁]
    J --> M[溢出检查优化]
    
    K --> N[适合生产环境]
    L --> N
    M --> N
```

### 算法流程图

```mermaid
flowchart TD
    A[开始] --> B[初始化result = 0]
    B --> C{x != 0?}
    
    C -->|否| D[返回result]
    C -->|是| E[提取个位digit]
    
    E --> F[检查溢出风险]
    F --> G{会溢出?}
    
    G -->|是| H[返回0]
    G -->|否| I[更新result]
    
    I --> J[result = result * 10 + digit]
    J --> K[x = x / 10]
    K --> C
    
    D --> L[结束]
    H --> L
```

### 边界情况处理

```mermaid
graph TD
    A[边界情况] --> B[x = 0]
    A --> C[x = 负数]
    A --> D[x = 最大/最小值]
    A --> E[反转后溢出]
    
    B --> F[直接返回0]
    C --> G[转为正数处理]
    D --> H[特殊溢出检查]
    E --> I[返回0]
    
    F --> J[避免无效计算]
    G --> J
    H --> J
    I --> J
```

### 时间复杂度分析

```mermaid
graph TD
    A[时间复杂度分析] --> B[数字位数]
    B --> C[循环次数]
    C --> D[每次操作]
    
    B --> E[log₁₀(n)]
    C --> F[O_log_n]
    D --> G[O_1]
    
    E --> H[n是整数值]
    F --> I[总时间复杂度]
    G --> I
    
    I --> J[O_log_n]
    J --> K[最优解法]
```

### 空间复杂度分析

```mermaid
graph TD
    A[空间复杂度分析] --> B[额外空间使用]
    B --> C[局部变量]
    C --> D[常数空间]
    
    D --> E[O_1]
    E --> F[原地算法]
    F --> G[空间效率最优]
```

### 关键优化点

```mermaid
graph TD
    A[优化策略] --> B[溢出检查优化]
    A --> C[符号处理优化]
    A --> D[循环优化]
    
    B --> E[乘法前检查]
    C --> F[统一处理正负数]
    D --> G[减少不必要的计算]
    
    E --> H[避免溢出]
    F --> H
    G --> H
```

### 实际应用场景

```mermaid
graph TD
    A[应用场景] --> B[数字处理]
    A --> C[密码学]
    A --> D[数据验证]
    A --> E[算法竞赛]
    
    B --> F[数字序列反转]
    C --> G[数字加密]
    D --> H[输入验证]
    E --> I[编程练习]
    
    F --> J[核心算法组件]
    G --> J
    H --> J
    I --> J
```

### 测试用例设计

```mermaid
graph TD
    A[测试用例] --> B[基础功能]
    A --> C[边界情况]
    A --> D[溢出测试]
    
    B --> E[正数反转]
    B --> F[负数反转]
    B --> G[零值处理]
    
    C --> H[最大32位整数]
    C --> I[最小32位整数]
    C --> J[单位数]
    
    D --> K[反转后溢出]
    D --> L[边界值测试]
    
    E --> M[验证正确性]
    F --> M
    G --> M
    H --> M
    I --> M
    J --> M
    K --> N[验证溢出处理]
    L --> N
```

### 代码实现要点

1. **溢出检查时机**：
   - 在 `result * 10` 之前检查
   - 避免实际溢出后再检查

2. **符号处理**：
   - 先转为正数处理
   - 最后恢复符号

3. **循环终止条件**：
   - 使用 `x != 0` 而不是 `x > 0`
   - 统一处理正负数

4. **边界值处理**：
   - 特殊处理最大/最小32位整数
   - 处理反转后溢出的情况

5. **性能优化**：
   - 使用位运算优化溢出检查
   - 减少不必要的条件判断

这个问题的关键在于**掌握数字位提取技巧**和**正确处理溢出情况**，通过数学运算实现整数的位序反转，同时确保结果在32位整数范围内。
