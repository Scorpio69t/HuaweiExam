# 64. 最小路径和

## 题目描述

给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

说明：每次只能向下或者向右移动一步。


## 示例 1：

![minpath](./images/minpath.jpg)

输入：grid = [[1,3,1],[1,5,1],[4,2,1]]
输出：7
解释：因为路径 1→3→1→1→1 的总和最小。


## 示例 2：

输入：grid = [[1,2,3],[4,5,6]]
输出：12


## 提示：

- m == grid.length
- n == grid[i].length
- 1 <= m, n <= 200
- 0 <= grid[i][j] <= 200

## 解题思路

### 问题深度分析

这是一道经典的**路径动态规划**问题，核心挑战在于：如何在O(m×n)时间内找到从左上角到右下角的最小路径和？这涉及到**动态规划状态定义**、**状态转移方程**和**空间优化**的综合应用。

#### 问题本质

对于一个m×n的网格，从左上角(0,0)到右下角(m-1,n-1)的路径问题：
- 每次只能**向右**或**向下**移动一步
- 路径上的数字总和要求**最小**
- 本质是在所有可能路径中找到代价最小的那条

#### 核心思想

**动态规划经典应用**：
1. **状态定义法**：定义dp[i][j]为到达位置(i,j)的最小路径和
2. **最优子结构**：到达(i,j)只能从(i-1,j)或(i,j-1)来
3. **状态转移方程**：dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])
4. **空间优化**：滚动数组降维至O(n)

#### 数学原理详解

假设网格为：
```
1  3  1
1  5  1
4  2  1
```

**DP表构建过程**：
```
初始化第一行和第一列：
1   4   5       (第一行累加：1, 1+3, 4+1)
2   ?   ?       (第一列累加：1, 1+1, 2+4)
6   ?   ?

填充其余位置：
1   4   5
2   7   6       dp[1][1] = 5 + min(4, 2) = 7
6   8   7       dp[1][2] = 1 + min(5, 7) = 6
                dp[2][1] = 2 + min(2, 7) = 4... 等

最终DP表：
1   4   5
2   7   6
6   8   7       答案：dp[2][2] = 7
```

**最优路径**：1→3→1→1→1 (总和=7)

**关键公式**：
- 边界条件：dp[0][0] = grid[0][0]
- 第一行：dp[0][j] = dp[0][j-1] + grid[0][j]
- 第一列：dp[i][0] = dp[i-1][0] + grid[i][0]
- 一般情况：dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])

#### 算法对比

| 算法         | 时间复杂度 | 空间复杂度 | 特点                         |
| ------------ | ---------- | ---------- | ---------------------------- |
| 二维DP       | O(m×n)     | O(m×n)     | 最直观，易理解和调试         |
| 一维DP       | O(m×n)     | O(n)       | 滚动数组优化，空间最优       |
| 原地修改     | O(m×n)     | O(1)       | 极致空间优化，但修改原数组   |
| 记忆化递归   | O(m×n)     | O(m×n)     | 自顶向下，思路自然           |
| 暴力DFS      | O(2^{m+n}) | O(m+n)     | 效率极低，仅作对比           |

注：一维DP和原地修改是工程推荐解法

### 算法流程图

#### 主算法流程（二维DP）

```mermaid
graph TD
    A[开始: 输入grid m×n] --> B{网格为空?}
    B -->|是| C[返回0]
    B -->|否| D[创建DP表 m×n]
    D --> E[初始化 dp[0][0] = grid[0][0]]
    E --> F[初始化第一行]
    F --> G[初始化第一列]
    G --> H[双重循环遍历]
    H --> I[dp[i][j] = grid[i][j] + min上,左]
    I --> J{遍历完成?}
    J -->|否| H
    J -->|是| K[返回 dp[m-1][n-1]]
```

#### 状态转移详细流程

```mermaid
graph TD
    A[状态转移核心] --> B[当前格子 i,j]
    B --> C[上方格子 i-1,j]
    B --> D[左侧格子 i,j-1]
    
    C --> E[上方路径和: dp[i-1][j]]
    D --> F[左侧路径和: dp[i][j-1]]
    
    E --> G[选择较小值]
    F --> G
    G --> H[加上当前格子值: grid[i][j]]
    H --> I[得到 dp[i][j]]
    
    style G fill:#fff3e0
    style I fill:#c8e6c9
```

#### 空间优化流程（滚动数组）

```mermaid
graph TD
    A[空间优化思想] --> B[观察：计算dp[i][j]只需dp[i-1][j]和dp[i][j-1]]
    B --> C[结论：只需保存一行数据]
    C --> D[使用一维数组dp长度为n]
    D --> E[逐行更新dp数组]
    
    E --> F[dp[j]代表上一行的值]
    F --> G[dp[j-1]代表当前行左侧的值]
    G --> H[原地更新: dp[j] = grid[i][j] + min上,左]
    H --> I[空间从O m×n 降至O n]
    
    style I fill:#c8e6c9
```

#### DP表填充可视化

```mermaid
graph TD
    A[DP表填充顺序] --> B[Step 1: 起点]
    B --> C[dp[0][0] = grid[0][0]]
    
    A --> D[Step 2: 第一行]
    D --> E[只能从左边来]
    E --> F[dp[0][j] = dp[0][j-1] + grid[0][j]]
    
    A --> G[Step 3: 第一列]
    G --> H[只能从上边来]
    H --> I[dp[i][0] = dp[i-1][0] + grid[i][0]]
    
    A --> J[Step 4: 其余格子]
    J --> K[从上或左取min]
    K --> L[dp[i][j] = grid[i][j] + min上,左]
```

### 复杂度分析

#### 时间复杂度详解

**二维DP**：O(m×n)
- 初始化第一行：O(n)
- 初始化第一列：O(m)
- 填充DP表：双重循环 O(m×n)
- 总计：O(n) + O(m) + O(m×n) = O(m×n)

**一维DP**：O(m×n)
- 初始化第一行：O(n)
- 逐行更新：外层循环m次，内层循环n次，O(m×n)
- 总计：O(m×n)

**原地修改**：O(m×n)
- 同样是双重循环遍历
- 只是直接在grid上修改，不额外分配空间

**记忆化递归**：O(m×n)
- 每个格子最多计算一次
- 记忆化确保不重复计算

#### 空间复杂度详解

**二维DP**：O(m×n)
- DP表大小：m×n

**一维DP**：O(n)
- 滚动数组：只保存一行，长度n
- 最优空间复杂度（不修改原数组的前提下）

**原地修改**：O(1)
- 直接在grid上修改
- 不需要额外空间
- 缺点：破坏原数组

**记忆化递归**：O(m×n)
- memo表：m×n
- 递归栈：最深O(m+n)
- 总计：O(m×n)

### 关键优化技巧

#### 技巧1：二维DP标准实现

```go
// 二维动态规划 - 最直观的解法
func minPathSumDP2D(grid [][]int) int {
    if len(grid) == 0 || len(grid[0]) == 0 {
        return 0
    }
    
    m, n := len(grid), len(grid[0])
    dp := make([][]int, m)
    for i := range dp {
        dp[i] = make([]int, n)
    }
    
    // 初始化起点
    dp[0][0] = grid[0][0]
    
    // 初始化第一行
    for j := 1; j < n; j++ {
        dp[0][j] = dp[0][j-1] + grid[0][j]
    }
    
    // 初始化第一列
    for i := 1; i < m; i++ {
        dp[i][0] = dp[i-1][0] + grid[i][0]
    }
    
    // 状态转移
    for i := 1; i < m; i++ {
        for j := 1; j < n; j++ {
            dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])
        }
    }
    
    return dp[m-1][n-1]
}
```

**优势**：
- 逻辑清晰，易于理解
- 便于调试和可视化DP表
- 面试首选表达方式

#### 技巧2：一维DP空间优化

```go
// 一维动态规划 - 滚动数组优化
func minPathSumDP1D(grid [][]int) int {
    if len(grid) == 0 || len(grid[0]) == 0 {
        return 0
    }
    
    m, n := len(grid), len(grid[0])
    dp := make([]int, n)
    
    // 初始化第一行
    dp[0] = grid[0][0]
    for j := 1; j < n; j++ {
        dp[j] = dp[j-1] + grid[0][j]
    }
    
    // 逐行更新
    for i := 1; i < m; i++ {
        // 更新第一列
        dp[0] += grid[i][0]
        
        // 更新其余列
        for j := 1; j < n; j++ {
            dp[j] = grid[i][j] + min(dp[j], dp[j-1])
            // dp[j]   = 上方（上一行同列）
            // dp[j-1] = 左方（当前行前一列）
        }
    }
    
    return dp[n-1]
}
```

**核心理解**：
- dp[j]在更新前代表"上一行第j列的值"
- dp[j-1]代表"当前行第j-1列的值"（已更新）
- 原地更新时，上一行的值被当前行覆盖

#### 技巧3：原地修改（极致优化）

```go
// 原地修改 - 直接在grid上DP
func minPathSumInPlace(grid [][]int) int {
    if len(grid) == 0 || len(grid[0]) == 0 {
        return 0
    }
    
    m, n := len(grid), len(grid[0])
    
    // 初始化第一行
    for j := 1; j < n; j++ {
        grid[0][j] += grid[0][j-1]
    }
    
    // 初始化第一列
    for i := 1; i < m; i++ {
        grid[i][0] += grid[i-1][0]
    }
    
    // 状态转移
    for i := 1; i < m; i++ {
        for j := 1; j < n; j++ {
            grid[i][j] += min(grid[i-1][j], grid[i][j-1])
        }
    }
    
    return grid[m-1][n-1]
}
```

**适用场景**：
- 不需要保留原数组
- 极致追求空间效率
- 在线编程测试（通常允许修改输入）

#### 技巧4：记忆化递归

```go
// 记忆化递归 - 自顶向下
func minPathSumMemo(grid [][]int) int {
    m, n := len(grid), len(grid[0])
    memo := make([][]int, m)
    for i := range memo {
        memo[i] = make([]int, n)
        for j := range memo[i] {
            memo[i][j] = -1
        }
    }
    
    var dfs func(i, j int) int
    dfs = func(i, j int) int {
        // 到达起点
        if i == 0 && j == 0 {
            return grid[0][0]
        }
        
        // 越界
        if i < 0 || j < 0 {
            return 1<<31 - 1  // 无穷大
        }
        
        // 已计算
        if memo[i][j] != -1 {
            return memo[i][j]
        }
        
        // 递归计算
        memo[i][j] = grid[i][j] + min(dfs(i-1, j), dfs(i, j-1))
        return memo[i][j]
    }
    
    return dfs(m-1, n-1)
}
```

**特点**：
- 从终点递归到起点
- 思路自然，符合人类思维
- 面试时可以作为DP推导的起点

### 边界情况处理

#### 边界1：空网格
```go
输入：grid = []
输出：0
处理：直接返回0
```

#### 边界2：单格子
```go
输入：grid = [[5]]
输出：5
处理：dp[0][0] = grid[0][0]
```

#### 边界3：单行
```go
输入：grid = [[1,2,3]]
输出：6
处理：只能向右，累加即可
```

#### 边界4：单列
```go
输入：grid = [[1],[2],[3]]
输出：6
处理：只能向下，累加即可
```

#### 边界5：全零网格
```go
输入：grid = [[0,0],[0,0]]
输出：0
处理：路径和为0
```

### 数学背景知识

#### 动态规划三要素

1. **最优子结构**：
   - 到达(i,j)的最优路径 = min(到达(i-1,j), 到达(i,j-1)) + grid[i][j]
   - 大问题的最优解包含子问题的最优解

2. **重叠子问题**：
   - 多条路径会经过同一格子
   - 记忆化避免重复计算

3. **无后效性**：
   - 当前状态只依赖已知的前置状态
   - 不依赖未来状态

#### 路径计数 vs 路径和

对比LeetCode 62（不同路径）：
- **62题**：计数问题，dp[i][j]表示路径数量
- **本题**：最优化问题，dp[i][j]表示最小路径和
- 状态转移：62题用加法，本题用min

#### 贪心 vs DP

为什么贪心不行？
```
反例：
2  1
1  100

贪心：2→1→100 = 103
最优：2→1→1   = 4
```
每步选局部最优不保证全局最优，必须用DP。

### 应用场景

1. **机器人路径规划**：栅格地图中的最短路径
2. **成本优化**：物流配送的最小成本路线
3. **游戏AI**：塔防游戏中敌人的最优路径
4. **图像处理**：图像缝合的最小误差路径
5. **芯片设计**：电路布线的最小代价

### 测试用例设计

#### 基础测试
```go
输入：grid = [[1,3,1],[1,5,1],[4,2,1]]
输出：7
路径：1→3→1→1→1

输入：grid = [[1,2,3],[4,5,6]]
输出：12
路径：1→2→3→6 或 1→2→5→6
```

#### 边界测试
```go
输入：grid = [[1]]
输出：1

输入：grid = [[1,2,3]]
输出：6

输入：grid = [[1],[2],[3]]
输出：6
```

#### 特殊测试
```go
输入：grid = [[0,0],[0,0]]
输出：0
说明：全零网格

输入：grid = [[1,1,1],[1,1,1],[1,1,1]]
输出：5
说明：所有路径代价相同
```

### 常见错误与陷阱

#### 错误1：忘记初始化边界
```go
// ❌ 错误：未初始化第一行第一列
dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])

// ✅ 正确：先初始化边界
dp[0][0] = grid[0][0]
for j := 1; j < n; j++ {
    dp[0][j] = dp[0][j-1] + grid[0][j]
}
for i := 1; i < m; i++ {
    dp[i][0] = dp[i-1][0] + grid[i][0]
}
```

#### 错误2：滚动数组更新顺序错误
```go
// ❌ 错误：先更新dp[j-1]会影响dp[j]
for j := 0; j < n; j++ {
    dp[j] = grid[i][j] + min(dp[j], dp[j-1])
}

// ✅ 正确：从左到右更新
dp[0] += grid[i][0]  // 先更新第一列
for j := 1; j < n; j++ {
    dp[j] = grid[i][j] + min(dp[j], dp[j-1])
}
```

#### 错误3：记忆化递归边界处理
```go
// ❌ 错误：越界时返回0
if i < 0 || j < 0 {
    return 0  // 会导致错误的min选择
}

// ✅ 正确：返回极大值
if i < 0 || j < 0 {
    return 1<<31 - 1  // 确保不会被min选中
}
```

#### 错误4：混淆路径数和路径和
```go
// ❌ 错误：用加法而不是min
dp[i][j] = grid[i][j] + dp[i-1][j] + dp[i][j-1]

// ✅ 正确：取较小值
dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])
```

### 实战技巧总结

1. **状态定义**：明确dp[i][j]的含义是"到达(i,j)的最小和"
2. **边界初始化**：第一行和第一列只有一条路径
3. **状态转移**：从上或左取min，加上当前格子值
4. **空间优化**：生产环境优先一维DP
5. **原地修改**：刷题时可用，实际工程需评估
6. **记忆化**：自顶向下思路清晰，便于推导

### 进阶扩展

#### 扩展1：返回具体路径
```go
// 在DP的同时记录路径选择
type PathInfo struct {
    sum  int
    path [][]int
}

func minPathWithPath(grid [][]int) [][]int {
    // dp过程中记录每步的选择（上/左）
    // 最后回溯构造完整路径
}
```

#### 扩展2：允许四个方向移动
```go
// 变成最短路径问题，使用Dijkstra或BFS
func minPathFourDirections(grid [][]int) int {
    // 需要visited标记避免重复访问
    // 使用优先队列（最小堆）
}
```

#### 扩展3：带障碍物的最小路径和
```go
// 结合LeetCode 63的障碍处理
func minPathSumWithObstacles(grid [][]int) int {
    // 障碍位置设为无穷大
    // 或者跳过不计算
}
```

## 代码实现

本题提供了四种不同的解法，重点掌握一维DP和原地修改。

## 测试结果

| 测试用例     | 二维DP | 一维DP | 原地修改 | 记忆化递归 |
| ------------ | ------ | ------ | -------- | ---------- |
| 基础测试     | ✅      | ✅      | ✅        | ✅          |
| 边界测试     | ✅      | ✅      | ✅        | ✅          |
| 大规模(200×200) | ✅  | ✅      | ✅        | ✅          |
| 性能测试     | 良好   | 最优   | 最优     | 良好       |

注：一维DP和原地修改在空间效率上最优

## 核心收获

1. **DP建模**：路径问题的标准DP模板
2. **空间优化**：滚动数组的正确使用
3. **状态转移**：min选择体现最优子结构
4. **边界处理**：第一行第一列的特殊初始化

## 应用拓展

- 机器人路径规划和导航
- 游戏中的AI寻路算法
- 物流配送的成本优化
- 图像处理中的缝合路径

