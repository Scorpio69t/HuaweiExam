# 10. 正则表达式匹配

## 题目描述

给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。

'.' 匹配任意单个字符
'*' 匹配零个或多个前面的那一个元素
所谓匹配，是要涵盖 整个 字符串 s 的，而不是部分字符串。

## 示例 1：

输入：s = "aa", p = "a"
输出：false
解释："a" 无法匹配 "aa" 整个字符串。

## 示例 2:

输入：s = "aa", p = "a*"
输出：true
解释：因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。

## 示例 3：

输入：s = "ab", p = ".*"
输出：true
解释：".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。
 
## 提示：

- 1 <= s.length <= 20
- 1 <= p.length <= 20
- s 只包含从 a-z 的小写字母。
- p 只包含从 a-z 的小写字母，以及字符 . 和 *。
- 保证每次出现字符 * 时，前面都匹配到有效的字符

## 解题思路

这道题要求实现一个支持 '.' 和 '*' 的正则表达式匹配器。这是一个经典的字符串匹配问题，需要处理复杂的模式匹配逻辑。

### 算法分析

这道题的核心思想是**动态规划状态转移**，主要解法包括：

1. **动态规划方法**：使用二维DP表记录匹配状态（推荐）
2. **递归方法**：带备忘录的递归实现
3. **优化版本**：减少空间复杂度的DP实现
4. **回溯方法**：不使用备忘录的递归实现

### 问题本质分析

```mermaid
graph TD
    A[正则表达式匹配] --> B[模式分析]
    B --> C[字符匹配]
    B --> D[星号处理]
    B --> E[通配符处理]
    
    C --> F[精确字符匹配]
    D --> G[零次或多次匹配]
    E --> H[任意字符匹配]
    
    F --> I[状态转移]
    G --> I
    H --> I
    
    I --> J[DP表填充]
    J --> K[最终匹配结果]
```

### 动态规划详解

```mermaid
flowchart TD
    A[创建DP表] --> B[初始化边界条件]
    B --> C[填充DP表]
    C --> D[返回最终结果]
    
    B --> E[dp[0][0] = true]
    B --> F[处理模式串开头的*号]
    
    C --> G[遍历字符串和模式串]
    G --> H{当前字符匹配?}
    
    H -->|是| I[dp[i][j] = dp[i-1][j-1]]
    H -->|否| J{当前模式是*号?}
    
    J -->|是| K[处理*号匹配]
    J -->|否| L[dp[i][j] = false]
    
    K --> M[匹配0次: dp[i][j-2]]
    K --> N[匹配多次: dp[i-1][j]]
    
    I --> O[继续下一位置]
    L --> O
    M --> P[dp[i][j] = dp[i][j-2]]
    N --> Q[dp[i][j] = dp[i][j] || dp[i-1][j]]
    
    P --> O
    Q --> O
    O --> R{还有位置?}
    R -->|是| G
    R -->|否| D
```

### DP表填充过程

```mermaid
graph TD
    A["示例: s='aa', p='a*'"] --> B[DP表初始化]
    
    B --> C["dp[0][0] = true"]
    C --> D["dp[0][1] = false (a)"]
    D --> E["dp[0][2] = true (a*)"]
    
    E --> F[填充第一行]
    F --> G["dp[1][0] = false"]
    G --> H["dp[1][1] = true (a匹配a)"]
    H --> I["dp[1][2] = true (a*匹配a)"]
    
    I --> J[填充第二行]
    J --> K["dp[2][0] = false"]
    K --> L["dp[2][1] = false (a不匹配aa)"]
    L --> M["dp[2][2] = true (a*匹配aa)"]
    
    M --> N["最终结果: dp[2][2] = true"]
```

### 星号处理策略

```mermaid
graph TD
    A[星号处理] --> B[匹配0次]
    A --> C[匹配1次]
    A --> D[匹配多次]
    
    B --> E[跳过当前字符和星号]
    C --> F[匹配当前字符]
    D --> G[继续匹配相同字符]
    
    E --> H[dp[i][j] = dp[i][j-2]]
    F --> I[dp[i][j] = dp[i-1][j-2]]
    G --> J[dp[i][j] = dp[i-1][j]]
    
    H --> K[状态转移]
    I --> K
    J --> K
```

### 各种解法对比

```mermaid
graph TD
    A[解法对比] --> B[动态规划]
    A --> C[递归方法]
    A --> D[优化版本]
    A --> E[回溯方法]
    
    B --> F[时间O_m*n空间O_m*n]
    C --> G[时间O_m*n空间O_m*n]
    D --> H[时间O_m*n空间O_n]
    E --> I[时间O_2^m+n空间O_m+n]
    
    B --> J[推荐解法]
    C --> K[易于理解]
    D --> L[空间优化]
    E --> M[理论分析]
    
    J --> N[性能稳定]
    K --> N
    L --> N
    M --> N
```

### 算法流程图

```mermaid
flowchart TD
    A[开始] --> B[创建DP表]
    B --> C[初始化边界条件]
    C --> D[i = 1, j = 1]
    
    D --> E{i <= m?}
    E -->|否| F[返回dp[m][n]]
    E -->|是| G{j <= n?}
    
    G -->|否| H[i++, j = 1]
    G -->|是| I{当前字符匹配?}
    
    I -->|是| J[dp[i][j] = dp[i-1][j-1]]
    I -->|否| K{当前模式是*号?}
    
    K -->|是| L[处理*号匹配]
    K -->|否| M[dp[i][j] = false]
    
    L --> N[匹配0次: dp[i][j-2]]
    N --> O[匹配多次: dp[i-1][j]]
    O --> P[dp[i][j] = dp[i][j] || dp[i-1][j]]
    
    J --> Q[j++]
    M --> Q
    P --> Q
    Q --> G
    H --> E
    F --> R[结束]
```

### 边界情况处理

```mermaid
graph TD
    A[边界情况] --> B[空字符串]
    A --> C[空模式]
    A --> D[模式以*开头]
    A --> E[字符串以*结尾]
    
    B --> F[只有模式都是x*形式才匹配]
    C --> G[只有空字符串才匹配]
    D --> H[*号前面必须有字符]
    E --> I[*号匹配任意字符]
    
    F --> J[特殊处理]
    G --> J
    H --> J
    I --> J
```

### 时间复杂度分析

```mermaid
graph TD
    A[时间复杂度分析] --> B[DP表大小]
    B --> C[填充操作]
    C --> D[总时间复杂度]
    
    B --> E[m*n]
    C --> F[O_1]
    D --> G[O_m*n]
    
    E --> H[m和n分别是字符串和模式串长度]
    F --> I[每个位置常数时间操作]
    G --> J[最优解法]
```

### 空间复杂度分析

```mermaid
graph TD
    A[空间复杂度分析] --> B[DP表存储]
    B --> C[优化策略]
    C --> D[最终空间复杂度]
    
    B --> E[O_m*n]
    C --> F[只保存当前行]
    D --> G[O_n]
    
    E --> H[二维DP表]
    F --> H
    G --> I[空间优化版本]
```

### 关键优化点

```mermaid
graph TD
    A[优化策略] --> B[空间优化]
    A --> C[状态转移优化]
    A --> D[边界条件优化]
    
    B --> E[使用一维DP数组]
    C --> F[减少不必要的计算]
    D --> G[提前处理特殊情况]
    
    E --> H[空间复杂度从O_m*n降到O_n]
    F --> H
    G --> H
```

### 实际应用场景

```mermaid
graph TD
    A[应用场景] --> B[文本编辑器]
    A --> C[搜索引擎]
    A --> D[数据验证]
    A --> E[编译器设计]
    
    B --> F[查找替换功能]
    C --> G[模糊搜索]
    D --> H[输入格式验证]
    E --> I[词法分析器]
    
    F --> J[核心算法组件]
    G --> J
    H --> J
    I --> J
```

### 测试用例设计

```mermaid
graph TD
    A[测试用例] --> B[基础功能]
    A --> C[边界情况]
    A --> D[复杂模式]
    
    B --> E[字符匹配]
    B --> F[通配符匹配]
    B --> G[星号匹配]
    
    C --> H[空字符串]
    C --> I[空模式]
    C --> J[单字符]
    
    D --> K[多重星号]
    D --> L[混合模式]
    
    E --> M[验证正确性]
    F --> M
    G --> M
    H --> M
    I --> M
    J --> M
    K --> N[验证算法稳定性]
    L --> N
```

### 代码实现要点

1. **DP表设计**：
   - dp[i][j]表示s的前i个字符与p的前j个字符是否匹配
   - 需要处理空字符串和空模式的边界情况

2. **星号处理**：
   - 匹配0次：dp[i][j] = dp[i][j-2]
   - 匹配多次：dp[i][j] = dp[i-1][j]
   - 需要检查前一个字符是否匹配

3. **状态转移**：
   - 普通字符：dp[i][j] = dp[i-1][j-1]
   - 通配符：dp[i][j] = dp[i-1][j-1]
   - 星号：复杂的组合逻辑

4. **边界条件**：
   - dp[0][0] = true（空字符串匹配空模式）
   - 处理模式串开头的*号情况
   - 字符串为空时的特殊处理

5. **空间优化**：
   - 只保存当前行和前一行
   - 使用滚动数组减少空间复杂度

这个问题的关键在于**理解动态规划的状态转移逻辑**和**正确处理星号的各种匹配情况**，通过构建DP表记录所有可能的匹配状态，实现高效的正则表达式匹配。
