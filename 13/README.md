# 13. 罗马数字转整数

## 题目描述

罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。

字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：

I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
给定一个罗马数字，将其转换成整数。


## 示例 1:

输入: s = "III"
输出: 3

## 示例 2:

输入: s = "IV"
输出: 4

## 示例 3:

输入: s = "IX"
输出: 9

## 示例 4:

输入: s = "LVIII"
输出: 58
解释: L = 50, V= 5, III = 3.

## 示例 5:

输入: s = "MCMXCIV"
输出: 1994
解释: M = 1000, CM = 900, XC = 90, IV = 4.

## 提示：

- 1 <= s.length <= 15
- s 仅含字符 ('I', 'V', 'X', 'L', 'C', 'D', 'M')
- 题目数据保证 s 是一个有效的罗马数字，且表示整数在范围 [1, 3999] 内
- 题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。
- IL 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。
- 关于罗马数字的详尽书写规则，可以参考 罗马数字 - 百度百科。

## 解题思路

这道题要求将罗马数字转换为整数，是第12题的反向操作。需要理解罗马数字的构成规则，特别是减法表示法的处理。这是一个字符串解析和数学计算的经典问题。

### 算法分析

这道题的核心思想是**减法规则识别**，主要解法包括：

1. **从右到左遍历法**：从右向左遍历，比较相邻字符的值（推荐）
2. **从左到右遍历法**：从左向右遍历，预判下一个字符
3. **数组映射优化**：使用数组替代map，提高查找效率
4. **递归方法**：使用分治思想逐步解析
5. **位运算优化**：使用位运算优化比较操作

### 问题本质分析

```mermaid
graph TD
    A[罗马数字转整数] --> B[字符值映射]
    B --> C[遍历策略]
    C --> D[减法规则识别]
    
    B --> E[I=1, V=5, X=10, L=50, C=100, D=500, M=1000]
    C --> F[从右到左遍历]
    C --> G[从左到右遍历]
    D --> H[小值在大值左边时减法]
    
    E --> I[建立映射关系]
    F --> J[处理减法规则]
    G --> J
    H --> K[最终结果计算]
    
    I --> L[转换策略]
    J --> L
    K --> L
```

### 从右到左遍历法详解

```mermaid
flowchart TD
    A[输入罗马数字字符串] --> B[初始化result=0, prevValue=0]
    B --> C[从右到左遍历字符串]
    
    C --> D{还有字符?}
    D -->|否| E[返回result]
    D -->|是| F[获取当前字符值]
    
    F --> G{当前值 < 前一个值?}
    G -->|是| H[result -= 当前值]
    G -->|否| I[result += 当前值]
    
    H --> J[更新prevValue]
    I --> J
    J --> K[移动到下一个字符]
    K --> C
    
    G --> L[减法规则处理]
    L --> M[如IV=4, IX=9, XL=40等]
```

### 转换过程可视化

```mermaid
graph TD
    A["输入: s = 'MCMXCIV'"] --> B[从右到左遍历]
    
    B --> C["第1步: V=5, prevValue=0, result=5"]
    C --> D["第2步: I=1, prevValue=5, 1<5, result=5-1=4"]
    D --> E["第3步: C=100, prevValue=1, 100>1, result=4+100=104"]
    
    E --> F["第4步: X=10, prevValue=100, 10<100, result=104-10=94"]
    F --> G["第5步: M=1000, prevValue=10, 1000>10, result=94+1000=1094"]
    
    G --> H["第6步: C=100, prevValue=1000, 100<1000, result=1094-100=994"]
    H --> I["第7步: M=1000, prevValue=100, 1000>100, result=994+1000=1994"]
    
    I --> J["最终结果: 1994"]
```

### 减法规则识别

```mermaid
graph TD
    A[减法规则] --> B[I在V或X左边]
    A --> C[X在L或C左边]
    A --> D[C在D或M左边]
    
    B --> E[IV = 5-1 = 4]
    B --> F[IX = 10-1 = 9]
    
    C --> G[XL = 50-10 = 40]
    C --> H[XC = 100-10 = 90]
    
    D --> I[CD = 500-100 = 400]
    D --> J[CM = 1000-100 = 900]
    
    E --> K[特殊情况处理]
    F --> K
    G --> K
    H --> K
    I --> K
    J --> K
```

### 各种解法对比

```mermaid
graph TD
    A[解法对比] --> B[从右到左遍历]
    A --> C[从左到右遍历]
    A --> D[数组映射优化]
    A --> E[递归方法]
    A --> F[位运算优化]
    
    B --> G[时间O_n空间O_1]
    C --> H[时间O_n空间O_1]
    D --> I[时间O_n空间O_1]
    E --> J[时间O_n空间O_n]
    F --> K[时间O_n空间O_1]
    
    B --> L[推荐解法]
    C --> M[易于理解]
    D --> N[性能最优]
    E --> O[分治思想]
    F --> P[位运算优化]
    
    L --> Q[平衡性能和可读性]
    M --> Q
    N --> Q
    O --> Q
    P --> Q
```

### 算法流程图

```mermaid
flowchart TD
    A[开始] --> B[初始化result=0, prevValue=0]
    B --> C[i = len(s)-1]
    
    C --> D{i >= 0?}
    D -->|否| E[返回result]
    D -->|是| F[获取当前字符值currentValue]
    
    F --> G{currentValue < prevValue?}
    G -->|是| H[result -= currentValue]
    G -->|否| I[result += currentValue]
    
    H --> J[prevValue = currentValue]
    I --> J
    J --> K[i--]
    K --> D
    
    G --> L[减法规则处理]
    L --> M[如IV、IX、XL、XC、CD、CM]
```

### 边界情况处理

```mermaid
graph TD
    A[边界情况] --> B[空字符串]
    A --> C[单字符]
    A --> D[两个字符减法]
    A --> E[多个字符]
    
    B --> F[返回0]
    C --> G[直接返回字符值]
    D --> H[检查减法规则]
    E --> I[正常遍历处理]
    
    F --> J[特殊情况处理]
    G --> J
    H --> J
    I --> J
```

### 时间复杂度分析

```mermaid
graph TD
    A[时间复杂度分析] --> B[字符串遍历]
    B --> C[每个字符处理]
    C --> D[总时间复杂度]
    
    B --> E[O_n]
    C --> F[O_1]
    D --> G[O_n]
    
    E --> H[n是字符串长度]
    F --> I[常数时间操作]
    G --> J[线性时间复杂度]
    J --> K[最优解法]
```

### 空间复杂度分析

```mermaid
graph TD
    A[空间复杂度分析] --> B[额外空间使用]
    B --> C[局部变量]
    C --> D[最终空间复杂度]
    
    B --> E[常数空间]
    C --> F[result, prevValue等]
    D --> G[O_1]
    
    E --> H[原地算法]
    F --> H
    G --> I[空间效率最优]
```

### 关键优化点

```mermaid
graph TD
    A[优化策略] --> B[遍历方向选择]
    A --> C[数据结构优化]
    A --> D[比较操作优化]
    
    B --> E[从右到左避免预判]
    C --> F[数组替代map]
    D --> G[位运算优化]
    
    E --> H[简化逻辑]
    F --> H
    G --> H
```

### 实际应用场景

```mermaid
graph TD
    A[应用场景] --> B[时钟显示]
    A --> C[章节编号]
    A --> D[版权年份]
    A --> E[历史文献]
    
    B --> F[罗马数字时钟解析]
    C --> G[书籍章节编号转换]
    D --> H[版权年份解析]
    E --> I[古典文献数字转换]
    
    F --> J[核心算法组件]
    G --> J
    H --> J
    I --> J
```

### 测试用例设计

```mermaid
graph TD
    A[测试用例] --> B[基础功能]
    A --> C[边界情况]
    A --> D[特殊规则]
    
    B --> E[单字符转换]
    B --> F[多字符加法]
    B --> G[混合运算]
    
    C --> H[空字符串]
    C --> I[单字符]
    C --> J[最大长度字符串]
    
    D --> K[减法规则]
    D --> L[IV、IX、XL、XC、CD、CM]
    
    E --> M[验证正确性]
    F --> M
    G --> M
    H --> M
    I --> M
    J --> M
    K --> N[验证特殊规则]
    L --> N
```

### 代码实现要点

1. **遍历方向选择**：
   - 从右到左遍历：避免预判下一个字符
   - 从左到右遍历：需要检查下一个字符

2. **减法规则识别**：
   - 当前值 < 前一个值时，需要减法
   - 当前值 >= 前一个值时，需要加法

3. **数据结构选择**：
   - 使用map：代码清晰，查找O(1)
   - 使用数组：性能最优，内存连续

4. **边界条件处理**：
   - 空字符串返回0
   - 单字符直接返回对应值
   - 确保所有情况都有正确的输出

5. **性能优化**：
   - 一次遍历完成转换
   - 使用数组替代map减少查找开销
   - 位运算优化比较操作

这个问题的关键在于**理解减法规则的识别逻辑**和**选择合适的遍历策略**，通过一次遍历和简单的比较操作，实现高效的罗马数字到整数的转换。特别是减法规则的处理，如IV、IX、XL、XC、CD、CM等特殊情况需要正确识别。
