# 4. 寻找两个正序数组的中位数

## 题目描述

给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。

算法的时间复杂度应该为 O(log (m+n)) 。

## 示例 1：

输入：nums1 = [1,3], nums2 = [2]
输出：2.00000
解释：合并数组 = [1,2,3] ，中位数 2

## 示例 2：

输入：nums1 = [1,2], nums2 = [3,4]
输出：2.50000
解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5
 
## 提示：

- nums1.length == m
- nums2.length == n
- 0 <= m <= 1000
- 0 <= n <= 1000
- 1 <= m + n <= 2000
- -10^6 <= nums1[i], nums2[i] <= 10^6

## 解题思路

这道题要求时间复杂度为 O(log(m+n))，这是一个经典的二分查找问题。

### 算法分析

这道题的核心思想是**分割数组**，主要解法包括：

1. **二分查找分割法**：使用二分查找找到正确的分割点
2. **合并排序法**：合并两个数组后找中位数（不满足时间复杂度要求）
3. **双指针法**：模拟合并过程（不满足时间复杂度要求）

### 问题本质分析

```mermaid
graph TD
    A[寻找两个正序数组中位数] --> B[分割策略]
    B --> C[二分查找分割点]
    B --> D[确保分割正确性]
    B --> E[计算中位数]
    
    C --> F[在较短数组中二分]
    D --> G[左半部分 ≤ 右半部分]
    E --> H[奇数取最大值]
    E --> I[偶数取平均值]
    
    F --> J[时间复杂度O_log_min_m_n]
    G --> K[边界条件处理]
    H --> L[返回结果]
    I --> L
```

### 二分查找分割算法详解

```mermaid
flowchart TD
    A[输入两个正序数组] --> B[确保nums1较短]
    B --> C[初始化二分查找范围]
    C --> D[计算分割点i和j]
    D --> E[检查分割是否有效]
    
    E --> F{分割有效?}
    F -->|是| G[计算中位数]
    F -->|否| H{调整方向}
    
    H -->|i太大| I[减小右边界]
    H -->|i太小| J[增大左边界]
    
    I --> D
    J --> D
    
    G --> K[返回结果]
    
    D --> L[i = left+right/2]
    D --> M[j = m+n+1/2 - i]
    
    E --> N[检查四个边界值]
    N --> O[nums1[i-1] ≤ nums2[j]]
    N --> P[nums2[j-1] ≤ nums1[i]]
```

### 分割策略可视化

```mermaid
graph TD
    A["nums1: [1, 3, 5, 7]"] --> B["nums2: [2, 4, 6, 8]"]
    
    B --> C[分割策略]
    C --> D["左半部分: nums1[0..i-1] + nums2[0..j-1]"]
    C --> E["右半部分: nums1[i..m-1] + nums2[j..n-1]"]
    
    D --> F["要求: 左半部分所有元素 ≤ 右半部分所有元素"]
    E --> F
    
    F --> G["中位数 = 左半部分最大值 或 左右半部分边界值平均值"]
```

### 分割点计算过程

```mermaid
graph TD
    A["示例: nums1=[1,3], nums2=[2]"] --> B[总长度: 3, 中位数位置: 2]
    
    B --> C[尝试分割点i=1]
    C --> D["左半部分: nums1[0..0] + nums2[0..0] = [1] + [2]"]
    D --> E["右半部分: nums1[1..1] + nums2[1..1] = [3] + []"]
    
    E --> F[检查分割有效性]
    F --> G["max(左半部分) = max(1,2) = 2"]
    G --> H["min(右半部分) = min(3,∞) = 3"]
    
    H --> I["2 ≤ 3 ✓ 分割有效"]
    I --> J[中位数 = 2]
```

### 边界情况处理

```mermaid
graph TD
    A[边界情况] --> B[i=0时]
    A --> C[i=m时]
    A --> D[j=0时]
    A --> E[j=n时]
    
    B --> F["nums1[i-1] = -∞"]
    C --> G["nums1[i] = +∞"]
    D --> H["nums2[j-1] = -∞"]
    E --> I["nums2[j] = +∞"]
    
    F --> J[确保比较逻辑正确]
    G --> J
    H --> J
    I --> J
```

### 算法流程图

```mermaid
flowchart TD
    A[开始] --> B[确保nums1较短]
    B --> C[初始化left=0, right=m]
    C --> D[left ≤ right?]
    
    D -->|否| E[返回0.0]
    D -->|是| F[计算i和j]
    
    F --> G[获取四个边界值]
    G --> H[检查分割有效性]
    
    H --> I{分割有效?}
    I -->|是| J{总长度奇偶?}
    I -->|否| K{调整方向?}
    
    J -->|奇数| L[返回左半部分最大值]
    J -->|偶数| M[返回左右边界平均值]
    
    K -->|i太大| N[right = i-1]
    K -->|i太小| O[left = i+1]
    
    N --> D
    O --> D
    
    L --> P[结束]
    M --> P
```

### 各种解法对比

```mermaid
graph TD
    A[解法对比] --> B[二分查找分割法]
    A --> C[合并排序法]
    A --> D[双指针模拟法]
    
    B --> E[时间O_log_min_m_n]
    B --> F[空间O_1]
    B --> G[满足题目要求]
    
    C --> H[时间O_m+n]
    C --> I[空间O_m+n]
    C --> J[不满足要求]
    
    D --> K[时间O_m+n]
    D --> L[空间O_1]
    D --> M[不满足要求]
    
    E --> N[推荐解法]
    H --> O[不推荐]
    K --> P[不推荐]
```

### 时间复杂度分析

```mermaid
graph TD
    A[时间复杂度分析] --> B[二分查找]
    B --> C[查找范围: min(m,n)]
    C --> D[每次查找: O_1]
    D --> E[总时间: O_log_min_m_n]
    
    E --> F[满足题目要求O_log_m+n]
    F --> G[最优解法]
```

### 空间复杂度分析

```mermaid
graph TD
    A[空间复杂度分析] --> B[额外空间使用]
    B --> C[几个局部变量]
    C --> D[常数空间O_1]
    
    D --> E[空间效率最优]
    E --> F[原地算法]
```

### 关键优化点

```mermaid
graph TD
    A[优化策略] --> B[数组交换]
    A --> C[边界处理]
    A --> D[提前返回]
    
    B --> E[确保nums1较短]
    C --> F[使用正负无穷]
    D --> G[找到分割点立即返回]
    
    E --> H[减少二分查找范围]
    F --> I[避免边界判断错误]
    G --> J[提高执行效率]
```

### 实际应用场景

```mermaid
graph TD
    A[应用场景] --> B[数据库查询]
    A --> C[统计分析]
    A --> D[机器学习]
    A --> E[金融分析]
    
    B --> F[分位数计算]
    C --> G[数据分布分析]
    D --> H[特征工程]
    E --> I[风险评估]
    
    F --> J[核心算法组件]
    G --> J
    H --> J
    I --> J
```

### 测试用例设计

```mermaid
graph TD
    A[测试用例] --> B[基础功能]
    A --> C[边界情况]
    A --> D[性能测试]
    
    B --> E[简单数组]
    B --> F[复杂数组]
    B --> G[不同长度]
    
    C --> H[空数组]
    C --> I[单元素数组]
    C --> J[最大最小值]
    
    D --> K[最大长度数组]
    D --> L[大量重复元素]
    
    E --> M[验证正确性]
    F --> M
    G --> M
    H --> M
    I --> M
    J --> M
    K --> N[验证性能]
    L --> N
```

### 代码实现要点

1. **数组交换优化**：
   - 确保nums1是较短的数组
   - 减少二分查找的范围

2. **分割点计算**：
   - i = (left + right) / 2
   - j = (m + n + 1) / 2 - i
   - 确保左右两部分元素数量平衡

3. **边界条件处理**：
   - 使用math.MinInt32和math.MaxInt32
   - 处理数组边界情况

4. **分割有效性检查**：
   - nums1[i-1] ≤ nums2[j]
   - nums2[j-1] ≤ nums1[i]

5. **中位数计算**：
   - 奇数情况：max(nums1[i-1], nums2[j-1])
   - 偶数情况：(max + min) / 2

这个问题的关键在于**理解分割策略**和**掌握二分查找技巧**，通过巧妙的分割将两个数组的问题转化为单个数组的二分查找问题，实现高效的中位数计算。
