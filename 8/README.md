# 8. 字符串转换整数 (atoi)

## 题目描述

请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数。

函数 myAtoi(string s) 的算法如下：

1. 空格：读入字符串并丢弃无用的前导空格（" "）
2. 符号：检查下一个字符（假设还未到字符末尾）为 '-' 还是 '+'。如果两者都不存在，则假定结果为正。
3. 转换：通过跳过前置零来读取该整数，直到遇到非数字字符或到达字符串的结尾。如果没有读取数字，则结果为0。
4. 舍入：如果整数数超过 32 位有符号整数范围 [−231,  231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被舍入为 −231 ，大于 231 − 1 的整数应该被舍入为 231 − 1 。

返回整数作为最终结果。

## 示例 1：

输入：s = "42"

输出：42

解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。

带下划线线的字符是所读的内容，插入符号是当前读入位置。
第 1 步："42"（当前没有读入字符，因为没有前导空格）
         ^
第 2 步："42"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）
         ^
第 3 步："42"（读入 "42"）
           ^
## 示例 2：

输入：s = " -042"

输出：-42

解释：

第 1 步："   -042"（读入前导空格，但忽视掉）
            ^
第 2 步："   -042"（读入 '-' 字符，所以结果应该是负数）
             ^
第 3 步："   -042"（读入 "042"，在结果中忽略前导零）
               ^
## 示例 3：

输入：s = "1337c0d3"

输出：1337

解释：

第 1 步："1337c0d3"（当前没有读入字符，因为没有前导空格）
         ^
第 2 步："1337c0d3"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）
         ^
第 3 步："1337c0d3"（读入 "1337"；由于下一个字符不是一个数字，所以读入停止）
             ^
## 示例 4：

输入：s = "0-1"

输出：0

解释：

第 1 步："0-1" (当前没有读入字符，因为没有前导空格)
         ^
第 2 步："0-1" (当前没有读入字符，因为这里不存在 '-' 或者 '+')
         ^
第 3 步："0-1" (读入 "0"；由于下一个字符不是一个数字，所以读入停止)
          ^
## 示例 5：

输入：s = "words and 987"

输出：0

解释：

读取在第一个非数字字符"w"处停止。


## 提示：

- 0 <= s.length <= 200
- s 由英文字母（大写和小写）、数字（0-9）、' '、'+'、'-' 和 '.' 组成

## 解题思路

这道题要求实现一个字符串转整数的函数，需要处理多种边界情况和状态转换。这是一个字符串解析和状态机的经典问题。

### 算法分析

这道题的核心思想是**状态机解析**，主要解法包括：

1. **状态机方法**：使用状态机管理不同的解析阶段
2. **优化版本**：简化逻辑，直接处理各种情况
3. **正则表达式思路**：使用字符串处理模拟正则匹配
4. **位运算优化**：使用位运算优化溢出检查

### 问题本质分析

```mermaid
graph TD
    A[字符串转整数] --> B[前导空格处理]
    B --> C[符号识别]
    C --> D[数字提取]
    D --> E[溢出检查]
    
    B --> F[跳过空格字符]
    C --> G[识别+/-符号]
    D --> H[逐位读取数字]
    E --> I[32位范围检查]
    
    F --> J[状态转换]
    G --> J
    H --> J
    I --> J
    
    J --> K[返回最终结果]
```

### 状态机详解

```mermaid
flowchart TD
    A[开始] --> B[START状态]
    B --> C{当前字符类型}
    
    C -->|空格| D[继续跳过空格]
    C -->|+/-| E[切换到SIGN状态]
    C -->|数字| F[切换到DIGIT状态]
    C -->|其他| G[切换到END状态]
    
    D --> C
    E --> H{下一个字符}
    F --> I[开始数字处理]
    
    H -->|数字| I
    H -->|其他| G
    
    I --> J{继续读取数字}
    J -->|数字| K[检查溢出并累加]
    J -->|其他| G
    
    K --> J
    G --> L[返回结果]
    L --> M[结束]
```

### 解析过程可视化

```mermaid
graph TD
    A["输入: ' -042'"] --> B[解析过程]
    
    B --> C["第1步: 跳过前导空格"]
    C --> D["剩余字符串: '-042'"]
    
    D --> E["第2步: 识别负号"]
    E --> F["sign = -1, 剩余: '042'"]
    
    F --> G["第3步: 读取数字"]
    G --> H["第1位: 0 (忽略前导零)"]
    H --> I["第2位: 4, result = 4"]
    I --> J["第3位: 2, result = 42"]
    
    J --> K["最终结果: -1 * 42 = -42"]
```

### 溢出检查策略

```mermaid
graph TD
    A[溢出检查策略] --> B[乘法前检查]
    B --> C[边界值处理]
    C --> D[符号相关处理]
    
    B --> E[result > MaxInt32/10]
    B --> F[result == MaxInt32/10 && digit > 7]
    B --> G[result < MinInt32/10]
    B --> H[result == MinInt32/10 && digit < -8]
    
    E --> I[返回MaxInt32或MinInt32]
    F --> I
    G --> I
    H --> I
    
    C --> J[正数溢出返回MaxInt32]
    C --> K[负数溢出返回MinInt32]
    
    I --> L[避免实际溢出]
    J --> L
    K --> L
```

### 各种解法对比

```mermaid
graph TD
    A[解法对比] --> B[状态机方法]
    A --> C[优化版本]
    A --> D[正则思路]
    A --> E[位运算优化]
    
    B --> F[时间O_n空间O_1]
    C --> G[时间O_n空间O_1]
    D --> H[时间O_n空间O_n]
    E --> I[时间O_n空间O_1]
    
    F --> J[结构清晰]
    G --> K[逻辑简洁]
    H --> L[直观易懂]
    I --> M[性能最优]
    
    J --> N[适合理解算法]
    K --> N[推荐实现]
    L --> N[适合调试]
    M --> N[生产环境]
```

### 算法流程图

```mermaid
flowchart TD
    A[开始] --> B{字符串是否为空?}
    B -->|是| C[返回0]
    B -->|否| D[跳过前导空格]
    
    D --> E{是否到达字符串末尾?}
    E -->|是| C
    E -->|否| F{当前字符是符号?}
    
    F -->|是| G[设置符号并跳过]
    F -->|否| H{当前字符是数字?}
    
    G --> H
    H -->|否| C
    H -->|是| I[开始数字处理]
    
    I --> J{继续读取数字}
    J -->|数字| K[检查溢出]
    K --> L{会溢出?}
    
    L -->|是| M[返回边界值]
    L -->|否| N[累加数字]
    
    N --> J
    J -->|非数字| O[返回结果]
    
    C --> P[结束]
    M --> P
    O --> P
```

### 边界情况处理

```mermaid
graph TD
    A[边界情况] --> B[空字符串]
    A --> C[只有空格]
    A --> D[只有符号]
    A --> E[符号后无数字]
    A --> F[前导零]
    A --> G[溢出情况]
    
    B --> H[返回0]
    C --> H
    D --> H
    E --> H
    F --> I[忽略前导零]
    G --> J[返回MaxInt32/MinInt32]
    
    H --> K[避免无效计算]
    I --> K
    J --> K
```

### 时间复杂度分析

```mermaid
graph TD
    A[时间复杂度分析] --> B[字符串遍历]
    B --> C[每个字符处理]
    C --> D[总时间复杂度]
    
    B --> E[O_n]
    C --> F[O_1]
    D --> G[O_n]
    
    E --> H[n是字符串长度]
    F --> I[常数时间操作]
    G --> J[线性时间复杂度]
    J --> K[最优解法]
```

### 空间复杂度分析

```mermaid
graph TD
    A[空间复杂度分析] --> B[额外空间使用]
    B --> C[局部变量]
    C --> D[常数空间]
    
    D --> E[O_1]
    E --> F[原地算法]
    F --> G[空间效率最优]
```

### 关键优化点

```mermaid
graph TD
    A[优化策略] --> B[溢出检查优化]
    A --> C[状态管理优化]
    A --> D[字符处理优化]
    
    B --> E[乘法前检查]
    C --> F[简化状态转换]
    D --> G[减少字符串操作]
    
    E --> H[避免实际溢出]
    F --> H
    G --> H
```

### 实际应用场景

```mermaid
graph TD
    A[应用场景] --> B[配置文件解析]
    A --> C[命令行参数]
    A --> D[数据文件读取]
    A --> E[网络协议解析]
    
    B --> F[配置文件数值]
    C --> G[命令行选项]
    D --> H[CSV数据解析]
    E --> I[HTTP头部解析]
    
    F --> J[核心算法组件]
    G --> J
    H --> J
    I --> J
```

### 测试用例设计

```mermaid
graph TD
    A[测试用例] --> B[基础功能]
    A --> C[边界情况]
    A --> D[溢出测试]
    
    B --> E[正常数字转换]
    B --> F[符号处理]
    B --> G[前导空格]
    
    C --> H[空字符串]
    C --> I[只有符号]
    C --> J[符号后无数字]
    
    D --> K[超过最大值]
    D --> L[小于最小值]
    
    E --> M[验证正确性]
    F --> M
    G --> M
    H --> M
    I --> M
    J --> M
    K --> N[验证溢出处理]
    L --> N
```

### 代码实现要点

1. **状态机设计**：
   - START：初始状态，处理空格和符号
   - SIGN：符号状态，等待数字
   - DIGIT：数字状态，持续读取数字
   - END：结束状态

2. **溢出检查时机**：
   - 在 `result * 10` 之前检查
   - 分别处理正数和负数溢出

3. **字符类型判断**：
   - 使用 `unicode.IsDigit()` 判断数字
   - 使用 `==` 判断空格和符号

4. **边界条件处理**：
   - 空字符串返回0
   - 只有空格返回0
   - 符号后无数字返回0

5. **性能优化**：
   - 使用位运算优化溢出检查
   - 减少不必要的字符串操作
   - 提前返回避免无效计算

这个问题的关键在于**理解状态机的设计**和**正确处理各种边界情况**，通过状态转换管理字符串解析的不同阶段，实现健壮的字符串转整数功能。

