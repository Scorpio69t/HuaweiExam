# HJ29 字符串加解密

## 描述
规定这样一种密码的加密方法：
- 对于密码中的英文字母，按照字母表顺序，向后移动一位，同时改变大小写，即 Z 转换为 a ，A 转换为 b ，B 转换为 c ，⋯ ，Y 转换为 z ，Z 转换为 a 。

- 对于密码中的数字，增加 1 ，9 转换为 0 。
字符串的解密方法即为加密方法的逆过程。

现在，对于给定的明文字符串 s ，将其加密；对于给定的密文字符串 t ，将其解密。

## 输入描述

第一行输入一个长度为 1<=length(s)<=10^3 的字符串 s ，代表给定的明文字符串；
第二行输入一个长度为 1<=length(t)<=10^3 的字符串 t ，代表给定的密文字符串。

除此之外，保证字符串 s 和 t 中仅包含英文字母和数字。

## 输出描述
第一行输出一个字符串，代表加密后的 s 。
第二行输出一个字符串，代表解密后的 t 。

## 示例1

输入：
abcdefg1
0BCDEFGH

输出：
BCDEFGH2
9abcdefg

## 解题思路

### 算法分析

这道题的核心是**字符映射转换**。主要涉及：

1. **字母加密**：向后移动一位并改变大小写
2. **数字加密**：加1，9变为0
3. **解密过程**：加密的逆操作
4. **边界处理**：Z→a, z→A, 9→0, 0→9

### 加密规则详解

```mermaid
graph TD
    A[输入字符] --> B{字符类型}
    B -->|字母| C{是否为边界字母?}
    B -->|数字| D{是否为9?}
    B -->|其他| E[保持不变]
    
    C -->|Z| F[转换为a]
    C -->|z| G[转换为A]
    C -->|其他| H[向后移动一位并改变大小写]
    
    D -->|是| I[转换为0]
    D -->|否| J[加1]
    
    F --> K[输出结果]
    G --> K
    H --> K
    I --> K
    J --> K
    E --> K
```

### 字母映射表

```mermaid
graph LR
    A[A] --> B[b]
    C[B] --> D[c]
    E[Y] --> F[z]
    G[Z] --> H[a]
    I[a] --> J[B]
    K[b] --> L[C]
    M[y] --> N[Z]
    O[z] --> P[A]
```

### 数字映射表

```mermaid
graph LR
    A[0] --> B[1]
    C[1] --> D[2]
    E[8] --> F[9]
    G[9] --> H[0]
```

### 算法流程图

```mermaid
flowchart TD
    A[读取明文] --> B[读取密文]
    B --> C[加密明文]
    C --> D[解密密文]
    D --> E[输出加密结果]
    E --> F[输出解密结果]
    
    G[加密过程] --> H[遍历每个字符]
    H --> I{字符类型}
    I -->|字母| J{边界情况}
    I -->|数字| K{是否为9}
    I -->|其他| L[保持不变]
    
    J -->|Z| M[转换为a]
    J -->|z| N[转换为A]
    J -->|其他| O[向后移动并改变大小写]
    
    K -->|是| P[转换为0]
    K -->|否| Q[加1]
    
    R[解密过程] --> S[遍历每个字符]
    S --> T{字符类型}
    T -->|字母| U{边界情况}
    T -->|数字| V{是否为0}
    T -->|其他| W[保持不变]
    
    U -->|A| X[转换为z]
    U -->|a| Y[转换为Z]
    U -->|其他| Z[向前移动并改变大小写]
    
    V -->|是| AA[转换为9]
    V -->|否| BB[减1]
```

### 代码实现思路

1. **字符分类处理**：
   - 使用`unicode.IsLetter()`判断字母
   - 使用`unicode.IsDigit()`判断数字
   - 其他字符保持不变

2. **字母加密逻辑**：
   - 边界情况：Z→a, z→A
   - 一般情况：向后移动一位并改变大小写
   - 使用`unicode.ToUpper()`和`unicode.ToLower()`转换大小写

3. **数字加密逻辑**：
   - 边界情况：9→0
   - 一般情况：加1

4. **解密逻辑**：
   - 字母：A→z, a→Z，其他向前移动并改变大小写
   - 数字：0→9，其他减1

### 时间复杂度分析

- **时间复杂度**：O(n)，其中n是字符串长度
- **空间复杂度**：O(n)，用于存储结果字符串

### 关键优化点

1. **字符分类优化**：使用unicode包的标准函数
2. **内存分配优化**：预分配结果数组
3. **边界处理优化**：特殊处理Z/z和9/0的情况
4. **大小写转换优化**：使用unicode包的内置函数

### 边界情况处理

1. **字母边界**：Z→a, z→A, A→z, a→Z
2. **数字边界**：9→0, 0→9
3. **非字母数字字符**：保持不变
4. **空字符串**：直接返回

### 测试用例分析

```mermaid
graph TD
    A[测试用例1] --> B[abcdefg1 → BCDEFGH2]
    C[测试用例2] --> D[0BCDEFGH → 9abcdefg]
    
    B --> E[验证字母加密]
    B --> F[验证数字加密]
    D --> G[验证字母解密]
    D --> H[验证数字解密]
    
    E --> I[大小写转换正确]
    F --> J[数字循环正确]
    G --> K[逆操作正确]
    H --> L[边界处理正确]
```

### 算法特点

1. **对称性**：加密和解密是互逆操作
2. **循环性**：字母和数字都有循环特性
3. **大小写转换**：字母在移动时同时改变大小写
4. **简单高效**：单次遍历即可完成转换

这个问题的关键在于**正确处理边界情况**和**实现对称的加密解密操作**，特别是字母的大小写转换和数字的循环处理。
