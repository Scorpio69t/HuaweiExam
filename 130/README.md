# 130. 被围绕的区域

## 描述

给你一个 m x n 的矩阵 board ，由若干字符 'X' 和 'O' 组成，捕获 所有 被围绕的区域：

连接：一个单元格与水平或垂直方向上相邻的单元格连接。
区域：连接所有 'O' 的单元格来形成一个区域。
围绕：如果您可以用 'X' 单元格 连接这个区域，并且区域中没有任何单元格位于 board 边缘，则该区域被 'X' 单元格围绕。
通过 原地 将输入矩阵中的所有 'O' 替换为 'X' 来 捕获被围绕的区域。你不需要返回任何值。

 

## 示例 1：

输入：board = [["X","X","X","X"],["X","O","O","X"],["X","X","O","X"],["X","O","X","X"]]

输出：[["X","X","X","X"],["X","X","X","X"],["X","X","X","X"],["X","O","X","X"]]

解释：

![1718167191](./images/1718167191-XNjUTG-image.png)

在上图中，底部的区域没有被捕获，因为它在 board 的边缘并且不能被围绕。

## 示例 2：

输入：board = [["X"]]

输出：[["X"]]

## 提示：

- m == board.length
- n == board[i].length
- 1 <= m, n <= 200
- board[i][j] 为 'X' 或 'O'

## 解题思路

### 算法分析

这道题是**图的遍历**和**连通性分析**的经典应用。主要解法包括：

1. **边界DFS法**：从边界的'O'开始DFS标记
2. **边界BFS法**：从边界的'O'开始BFS标记
3. **并查集法**：使用并查集维护连通性
4. **逆向思维法**：标记不能被围绕的区域

### 问题本质分析

```mermaid
graph TD
    A[被围绕的区域] --> B[图的连通性问题]
    B --> C[边界DFS]
    B --> D[边界BFS]
    B --> E[并查集]
    
    C --> F[从边界'O'开始标记]
    D --> G[层次遍历标记]
    E --> H[连通分量分析]
    
    F --> I[时间复杂度O_mn空间复杂度O_mn]
    G --> J[时间复杂度O_mn空间复杂度O_mn]
    H --> K[时间复杂度O_mn×α空间复杂度O_mn]
```

### 边界DFS算法详解

```mermaid
flowchart TD
    A[输入矩阵board] --> B[遍历矩阵边界]
    B --> C{边界位置是'O'?}
    C -->|否| D[继续下一个边界位置]
    C -->|是| E[从该位置开始DFS]
    
    E --> F[标记当前位置为临时字符]
    F --> G[向四个方向递归]
    G --> H{相邻位置是'O'?}
    
    H -->|是| I[递归调用DFS]
    H -->|否| J[跳过该方向]
    
    I --> G
    J --> G
    G --> K{四个方向都处理完?}
    K -->|否| G
    K -->|是| L[返回上级]
    
    D --> M{所有边界位置遍历完?}
    L --> M
    M -->|否| B
    M -->|是| N[遍历整个矩阵]
    
    N --> O{当前位置是'O'?}
    O -->|是| P[修改为'X' - 被围绕]
    O -->|否| Q{当前位置是临时标记?}
    Q -->|是| R[恢复为'O' - 不被围绕]
    Q -->|否| S[保持不变]
    
    P --> T[继续下一个位置]
    R --> T
    S --> T
    T --> U{矩阵遍历完成?}
    U -->|否| N
    U -->|是| V[算法结束]
```

### 边界BFS算法详解

```mermaid
flowchart TD
    A[边界BFS算法] --> B[初始化队列]
    B --> C[遍历矩阵边界]
    C --> D{边界位置是'O'?}
    D -->|是| E[加入队列并标记]
    D -->|否| F[继续下一个边界]
    
    E --> G{队列为空?}
    F --> G
    G -->|是| H[开始最终处理]
    G -->|否| I[取出队头元素]
    
    I --> J[检查四个方向]
    J --> K{相邻位置是'O'?}
    K -->|是| L[加入队列并标记]
    K -->|否| M[检查下一方向]
    
    L --> N{四个方向检查完?}
    M --> N
    N -->|否| J
    N -->|是| G
    
    H --> O[遍历整个矩阵]
    O --> P{位置是'O'?}
    P -->|是| Q[修改为'X']
    P -->|否| R{位置是临时标记?}
    R -->|是| S[恢复为'O']
    R -->|否| T[保持不变]
    
    Q --> U[继续下一位置]
    S --> U
    T --> U
    U --> V{遍历完成?}
    V -->|否| O
    V -->|是| W[结束]
```

### 并查集算法详解

```mermaid
flowchart TD
    A[并查集算法] --> B[初始化并查集]
    B --> C[添加虚拟边界节点]
    C --> D[遍历矩阵所有位置]
    
    D --> E{当前位置是'O'?}
    E -->|否| F[跳过当前位置]
    E -->|是| G{位置在边界?}
    
    G -->|是| H[与虚拟边界节点合并]
    G -->|否| I[检查相邻的'O']
    
    H --> J[检查四个方向相邻]
    I --> J
    J --> K{相邻位置是'O'?}
    K -->|是| L[合并两个节点]
    K -->|否| M[检查下一方向]
    
    L --> N{四个方向检查完?}
    M --> N
    N -->|否| J
    N -->|是| O[继续下一位置]
    
    F --> O
    O --> P{所有位置遍历完?}
    P -->|否| D
    P -->|是| Q[最终处理阶段]
    
    Q --> R[再次遍历矩阵]
    R --> S{位置是'O'?}
    S -->|否| T[保持不变]
    S -->|是| U{与边界连通?}
    U -->|是| V[保持为'O']
    U -->|否| W[修改为'X']
    
    T --> X[下一位置]
    V --> X
    W --> X
    X --> Y{遍历完成?}
    Y -->|否| R
    Y -->|是| Z[算法结束]
```

### 算法流程图

```mermaid
flowchart TD
    A[开始] --> B[输入验证]
    B --> C{矩阵为空或边界情况?}
    C -->|是| D[直接返回]
    C -->|否| E[选择算法]
    
    E --> F[边界DFS]
    E --> G[边界BFS]
    E --> H[并查集]
    
    F --> I[从边界'O'开始标记]
    G --> J[用队列层次遍历]
    H --> K[构建连通分量]
    
    I --> L[DFS递归标记连通的'O']
    J --> M[BFS层次标记连通的'O']
    K --> N[合并相邻的'O'节点]
    
    L --> O[最终处理阶段]
    M --> O
    N --> O
    
    O --> P[遍历整个矩阵]
    P --> Q{当前位置处理规则}
    Q --> R[未标记的'O' → 'X']
    Q --> S[已标记的'O' → 恢复'O']
    Q --> T['X' → 保持不变]
    
    R --> U[继续下一位置]
    S --> U
    T --> U
    U --> V{矩阵处理完成?}
    V -->|否| P
    V -->|是| W[算法结束]
```

### 边界情况分析

```mermaid
graph TD
    A[边界情况] --> B[空矩阵]
    A --> C[单行单列]
    A --> D[全是'X']
    A --> E[全是'O']
    A --> F[边界都是'O']
    
    B --> G[直接返回]
    C --> H[无内部区域，不修改]
    D --> I[无'O'需要处理]
    E --> J[所有'O'都不被围绕]
    F --> K[所有'O'都连通到边界]
```

### 各种解法对比

```mermaid
graph TD
    A[解法对比] --> B[边界DFS]
    A --> C[边界BFS]
    A --> D[并查集]
    A --> E[朴素DFS]
    
    B --> F[时间O_mn空间O_递归栈]
    C --> G[时间O_mn空间O_队列]
    D --> H[时间O_mn×α空间O_mn]
    E --> I[时间O_mn²空间复杂]
    
    F --> J[推荐递归友好]
    G --> K[推荐迭代稳定]
    H --> L[适合复杂连通性]
    I --> M[效率低不推荐]
```

### 时间复杂度分析

- **边界DFS**：O(m×n)，每个位置最多访问一次
- **边界BFS**：O(m×n)，每个位置最多访问一次
- **并查集**：O(m×n×α(m×n))，α为反阿克曼函数
- **朴素方法**：O(m²×n²)，需要多次完整遍历

### 空间复杂度分析

- **边界DFS**：O(m×n)，最坏情况递归栈深度
- **边界BFS**：O(m×n)，队列最大长度
- **并查集**：O(m×n)，存储父节点数组
- **原地修改**：O(1)，不考虑递归栈

### 关键优化点

```mermaid
graph TD
    A[优化策略] --> B[逆向思维]
    A --> C[边界优先]
    A --> D[原地修改]
    A --> E[早期剪枝]
    
    B --> F[标记不被围绕的]
    C --> G[从边界开始搜索]
    D --> H[避免额外空间]
    E --> I[减少不必要搜索]
    
    F --> J[算法效率提升]
    G --> J
    H --> J
    I --> J
```

### 实际应用场景

```mermaid
graph TD
    A[应用场景] --> B[图像处理]
    A --> C[游戏开发]
    A --> D[地理信息]
    A --> E[网络分析]
    
    B --> F[图像分割算法]
    C --> G[地形围圈检测]
    D --> H[地理区域分析]
    E --> I[网络连通性]
    
    F --> J[核心算法组件]
    G --> J
    H --> J
    I --> J
```

### DFS递归过程详解

```mermaid
graph TD
    A[DFS递归过程] --> B[当前位置检查]
    B --> C{位置合法且为'O'?}
    C -->|否| D[返回上级]
    C -->|是| E[标记当前位置]
    
    E --> F[递归上方]
    F --> G[递归下方]
    G --> H[递归左方]
    H --> I[递归右方]
    
    I --> J[所有方向完成]
    J --> D
    
    D --> K[回到上级调用]
```

### 测试用例设计

```mermaid
graph TD
    A[测试用例] --> B[基础功能]
    A --> C[边界情况]
    A --> D[复杂情况]
    
    B --> E[标准围绕区域]
    B --> F[边界连通区域]
    B --> G[混合情况]
    
    C --> H[空矩阵]
    C --> I[单元素矩阵]
    C --> J[单行单列]
    
    D --> K[大规模矩阵]
    D --> L[复杂连通模式]
    
    E --> M[验证正确性]
    F --> M
    G --> M
    H --> M
    I --> M
    J --> M
    K --> N[验证性能]
    L --> N
```

### 算法扩展

```mermaid
graph TD
    A[算法扩展] --> B[岛屿问题系列]
    A --> C[连通分量计数]
    A --> D[图的着色问题]
    A --> E[迷宫问题]
    
    B --> F[岛屿数量/最大面积]
    C --> G[无向图连通性]
    D --> H[区域划分染色]
    E --> I[路径查找问题]
    
    F --> J[图遍历问题家族]
    G --> J
    H --> J
    I --> J
```

### 代码实现要点

1. **边界处理**：
   - 正确处理矩阵边界索引
   - 避免数组越界访问
   - 特殊情况的提前返回

2. **状态标记**：
   - 使用临时标记区分不同状态
   - 最终恢复或修改为目标状态
   - 避免重复访问同一位置

3. **搜索策略**：
   - 从边界开始而非内部
   - 四个方向的遍历顺序
   - 递归终止条件的设置

4. **空间优化**：
   - 原地修改减少空间消耗
   - 合理选择DFS或BFS
   - 避免不必要的数据结构

### 手工验证示例

```mermaid
graph TD
    A["示例矩阵处理过程"] --> B[原始状态]
    B --> C["X X X X<br/>X O O X<br/>X X O X<br/>X O X X"]
    
    C --> D[边界标记阶段]
    D --> E["X X X X<br/>X O O X<br/>X X O X<br/>X T X X"]
    
    E --> F[最终处理阶段]
    F --> G["X X X X<br/>X X X X<br/>X X X X<br/>X O X X"]
    
    G --> H[说明：T表示临时标记]
    H --> I[底部O连通边界，保留]
    I --> J[内部O被围绕，变为X]
```

这个问题的关键在于**理解逆向思维的重要性**和**掌握从边界开始搜索的技巧**，通过标记不能被围绕的区域来解决问题。

