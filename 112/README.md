# 112. 路径总和

## 描述

给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。

叶子节点 是指没有子节点的节点。

## 示例 1

![pathsum1](./images/pathsum1.jpg)

输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
输出：true
解释：等于目标和的根节点到叶节点路径如上图所示。

## 示例 2

![pathsum2](./images/pathsum2.jpg)

输入：root = [1,2,3], targetSum = 5
输出：false
解释：树中存在两条根节点到叶子节点的路径：
(1 --> 2): 和为 3
(1 --> 3): 和为 4
不存在 sum = 5 的根节点到叶子节点的路径。

## 示例 3

输入：root = [], targetSum = 0
输出：false
解释：由于树是空的，所以不存在根节点到叶子节点的路径。


## 提示

- 树中节点的数目在范围 [0, 5000] 内
- -1000 <= Node.val <= 1000
- -1000 <= targetSum <= 1000

## 解题思路

### 算法分析

这道题的核心是**二叉树递归遍历**和**路径和计算**。主要涉及：

1. **深度优先搜索（DFS）**：遍历从根节点到叶子节点的所有路径
2. **递归思想**：将大问题分解为子问题
3. **路径和累加**：在遍历过程中累加节点值
4. **叶子节点判断**：确定路径的终点

### 问题本质分析

```mermaid
graph TD
    A[路径总和问题] --> B[二叉树遍历]
    B --> C[根节点到叶子节点]
    B --> D[路径和计算]
    C --> E[深度优先搜索DFS]
    D --> F[递归累加]
    E --> G[前序遍历]
    F --> G
    G --> H[叶子节点判断]
    H --> I[返回结果]
```

### 递归思路分析

```mermaid
graph TD
    A[递归思路] --> B[基本情况]
    A --> C[递归情况]
    
    B --> D[空节点返回false]
    B --> E[叶子节点检查和]
    
    C --> F[左子树递归]
    C --> G[右子树递归]
    
    E --> H[值等于剩余目标和]
    F --> I[targetSum - node.val]
    G --> I
    I --> J[任一子树返回true则成功]
```

### 算法流程详解

```mermaid
flowchart TD
    A[开始遍历节点] --> B{节点是否为空?}
    B -->|是| C[返回false]
    B -->|否| D{是否为叶子节点?}
    
    D -->|是| E{节点值等于剩余目标和?}
    E -->|是| F[返回true]
    E -->|否| G[返回false]
    
    D -->|否| H[计算剩余目标和]
    H --> I[递归遍历左子树]
    H --> J[递归遍历右子树]
    
    I --> K{左子树返回true?}
    J --> L{右子树返回true?}
    
    K -->|是| F
    L -->|是| F
    K -->|否| M{右子树是否也为false?}
    L -->|否| M
    M -->|是| G
    M -->|否| F
```

### 叶子节点判断

```mermaid
graph TD
    A[叶子节点判断] --> B[左子树为空]
    A --> C[右子树为空]
    B --> D[同时满足]
    C --> D
    D --> E[确认为叶子节点]
    
    F[非叶子节点] --> G[左子树不为空]
    F --> H[右子树不为空]
    G --> I[或者任一不为空]
    H --> I
    I --> J[继续递归遍历]
```

### 递归状态转移

```mermaid
graph TD
    A[状态转移] --> B[当前状态]
    B --> C[节点值: node.val]
    B --> D[剩余目标和: targetSum]
    
    E[转移到子状态] --> F[左子树状态]
    E --> G[右子树状态]
    
    F --> H[剩余和: targetSum - node.val]
    G --> H
    H --> I[递归调用]
    I --> J[返回结果合并]
```

### 代码实现思路

1. **节点定义**：
   - 标准二叉树节点结构
   - 包含值、左子树、右子树指针

2. **递归函数设计**：
   - 参数：当前节点、剩余目标和
   - 返回值：是否存在满足条件的路径
   - 边界条件：空节点和叶子节点

3. **路径判断逻辑**：
   - 空节点直接返回false
   - 叶子节点检查值是否等于剩余目标和
   - 非叶子节点递归检查左右子树

### 时间复杂度分析

- **时间复杂度**：O(n)，其中n是树中节点的数量
- **空间复杂度**：O(h)，其中h是树的高度（递归栈深度）

### 关键优化点

1. **提前终止**：找到满足条件的路径立即返回
2. **短路求值**：利用逻辑或操作的短路特性
3. **递归优化**：避免不必要的重复计算
4. **边界处理**：正确处理空树和单节点情况

### 边界情况处理

1. **空树**：根节点为空，直接返回false
2. **单节点树**：根节点即为叶子节点，检查值是否等于目标和
3. **负数节点**：正确处理负值节点的情况
4. **目标和为0**：特殊情况的正确处理

### 算法变种分析

```mermaid
graph TD
    A[路径总和变种] --> B[路径总和I]
    A --> C[路径总和II]
    A --> D[路径总和III]
    
    B --> E[存在性判断]
    C --> F[返回所有路径]
    D --> G[任意路径和]
    
    E --> H[DFS递归]
    F --> I[回溯算法]
    G --> J[双重DFS]
```

### 测试用例分析

```mermaid
graph TD
    A[示例1: 5,4,8,11,null,13,4,7,2,null,null,null,1] --> B[目标和: 22]
    B --> C[路径: 5→4→11→2 = 22]
    C --> D[返回: true]
    
    E[示例2: 1,2,3] --> F[目标和: 5]
    F --> G[路径1: 1→2 = 3]
    F --> H[路径2: 1→3 = 4]
    G --> I[都不等于5]
    H --> I
    I --> J[返回: false]
    
    K[示例3: ] --> L[空树]
    L --> M[返回: false]
    
    D --> N[验证算法正确性]
    J --> N
    M --> N
```

### 递归树示例

```mermaid
graph TD
    A["hasPathSum(5, 22)"] --> B["hasPathSum(4, 17)"]
    A --> C["hasPathSum(8, 17)"]
    
    B --> D["hasPathSum(11, 13)"]
    C --> E["hasPathSum(13, 9)"]
    C --> F["hasPathSum(4, 9)"]
    
    D --> G["hasPathSum(7, 2)"]
    D --> H["hasPathSum(2, 2)"]
    
    G --> I["叶子节点: 7 ≠ 2, false"]
    H --> J["叶子节点: 2 = 2, true"]
    
    J --> K["返回true"]
    K --> L["最终结果: true"]
```

### 算法特点

1. **递归简洁**：代码结构清晰，易于理解
2. **DFS遍历**：深度优先搜索所有路径
3. **提前返回**：找到答案即可返回
4. **空间高效**：只使用递归栈空间

### 实际应用场景

1. **文件系统**：查找指定大小的文件路径
2. **游戏开发**：寻路算法中的路径代价计算
3. **决策树**：业务逻辑中的条件判断路径
4. **网络路由**：最短路径算法的变种

### 相关问题扩展

```mermaid
graph TD
    A[相关问题] --> B[路径总和II]
    A --> C[路径总和III]
    A --> D[二叉树的最大路径和]
    A --> E[从根到叶的二进制数之和]
    
    B --> F[回溯算法]
    C --> G[前缀和+哈希表]
    D --> H[动态规划思想]
    E --> I[位运算优化]
    
    F --> J[算法模式扩展]
    G --> J
    H --> J
    I --> J
```

### 代码优化技巧

```mermaid
graph TD
    A[代码优化] --> B[递归优化]
    B --> C[尾递归转换]
    C --> D[栈模拟递归]
    
    A --> E[逻辑优化]
    E --> F[短路求值]
    F --> G[提前返回]
    
    D --> H[性能提升]
    G --> H
    H --> I[代码质量提升]
```

### 错误处理策略

```mermaid
graph TD
    A[错误处理] --> B[输入验证]
    B --> C[空指针检查]
    C --> D[边界值处理]
    
    A --> E[异常情况]
    E --> F[栈溢出防护]
    F --> G[内存管理]
    
    D --> H[程序健壮性]
    G --> H
    H --> I[生产环境适用]
```

这个问题的关键在于**正确理解递归的本质**和**准确判断叶子节点**，通过深度优先搜索遍历所有可能的根到叶路径，找到满足目标和的路径。

