# 23. 合并 K 个升序链表

# 描述

给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。

## 示例 1

输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
解释：链表数组如下：
[
  1->4->5,
  1->3->4,
  2->6
]
将它们合并到一个有序链表中得到。
1->1->2->3->4->4->5->6

## 示例 2

输入：lists = []
输出：[]

## 示例 3

输入：lists = [[]]
输出：[]

## 提示

- k == lists.length
- 0 <= k <= 10^4
- 0 <= lists[i].length <= 500
- -10^4 <= lists[i][j] <= 10^4
- lists[i] 按 升序 排列
- lists[i].length 的总和不超过 10^4

## 解题思路

### 算法分析

这道题是**链表合并**和**分治算法**的经典应用。主要解法包括：

1. **逐一合并法**：依次合并两个链表，简单但效率低
2. **分治合并法**：类似归并排序，递归分治合并
3. **优先队列法**：使用最小堆维护各链表头节点
4. **数组排序法**：收集所有节点后排序重建链表

### 问题本质分析

```mermaid
graph TD
    A[合并K个升序链表] --> B[多路归并问题]
    B --> C[两两合并策略]
    B --> D[分治策略]
    B --> E[堆优化策略]
    
    C --> F[逐一合并]
    D --> G[分治合并]
    E --> H[优先队列]
    
    F --> I[时间复杂度O_kn]
    G --> J[时间复杂度O_nlogk]
    H --> K[时间复杂度O_nlogk]
```

### 分治算法详解

```mermaid
flowchart TD
    A[K个链表分治合并] --> B{链表数量判断}
    B -->|空数组| C[返回null]
    B -->|单个链表| D[直接返回]
    B -->|多个链表| E[分治递归]
    
    E --> F[左半部分合并]
    E --> G[右半部分合并]
    F --> H[递归调用]
    G --> I[递归调用]
    
    H --> J[合并两个有序链表]
    I --> J
    J --> K[返回合并结果]
```

### 两个链表合并过程

```mermaid
graph TD
    A[合并两个有序链表] --> B[创建虚拟头节点]
    B --> C[双指针遍历]
    C --> D{比较节点值}
    
    D -->|list1较小| E[连接list1节点]
    D -->|list2较小| F[连接list2节点]
    
    E --> G[移动list1指针]
    F --> H[移动list2指针]
    
    G --> I{是否遍历完成}
    H --> I
    I -->|否| D
    I -->|是| J[连接剩余节点]
    J --> K[返回结果链表]
```

### 分治树结构

```mermaid
graph TD
    A[合并8个链表] --> B[左4个]
    A --> C[右4个]
    
    B --> D[左2个]
    B --> E[右2个]
    C --> F[左2个]
    C --> G[右2个]
    
    D --> H[链表1]
    D --> I[链表2]
    E --> J[链表3]
    E --> K[链表4]
    F --> L[链表5]
    F --> M[链表6]
    G --> N[链表7]
    G --> O[链表8]
```

### 优先队列解法

```mermaid
flowchart TD
    A[优先队列解法] --> B[初始化最小堆]
    B --> C[所有链表头节点入堆]
    C --> D{堆是否为空}
    
    D -->|空| E[合并完成]
    D -->|非空| F[取出最小节点]
    
    F --> G[连接到结果链表]
    G --> H{节点有后继}
    H -->|有| I[后继节点入堆]
    H -->|无| J[继续下一轮]
    I --> J
    J --> D
```

### 各种解法对比

```mermaid
graph TD
    A[解法对比] --> B[逐一合并]
    A --> C[分治合并]
    A --> D[优先队列]
    A --> E[数组排序]
    
    B --> F[时间O_kn空间O常数]
    C --> G[时间O_nlogk空间O_logk]
    D --> H[时间O_nlogk空间O_k]
    E --> I[时间O_nlogn空间O_n]
    
    F --> J[实现简单效率低]
    G --> K[经典分治推荐]
    H --> L[堆优化稳定]
    I --> M[简单粗暴]
```

### 算法流程图

```mermaid
flowchart TD
    A[输入K个升序链表] --> B{选择算法}
    B -->|分治法| C[分治合并]
    B -->|优先队列| D[堆合并]
    B -->|逐一合并| E[顺序合并]
    
    C --> F[递归分割]
    F --> G[两两合并]
    G --> H[递归向上合并]
    H --> I[返回最终结果]
    
    D --> J[建立最小堆]
    J --> K[依次取最小节点]
    K --> L[构建结果链表]
    L --> I
    
    E --> M[依次合并相邻链表]
    M --> N[重复直到剩一个]
    N --> I
```

### 代码实现思路

1. **链表节点定义**：
   - 标准单链表节点结构
   - 包含值和下一个节点指针

2. **分治合并实现**：
   - 递归分割链表数组
   - 合并两个有序链表的经典算法
   - 时间复杂度最优

3. **优先队列实现**：
   - 使用堆维护所有链表的当前最小节点
   - 每次取出最小节点并添加其后继
   - 适合K很大的情况

4. **边界处理**：
   - 空数组、单链表、空链表的处理
   - 链表长度不等的情况

### 时间复杂度分析

- **逐一合并法**：O_kn，k为链表数量，n为总节点数
- **分治合并法**：O_nlogk，最优解法
- **优先队列法**：O_nlogk，稳定高效
- **数组排序法**：O_nlogn，简单但空间消耗大

### 空间复杂度分析

- **逐一合并法**：O常数，原地操作
- **分治合并法**：O_logk，递归栈深度
- **优先队列法**：O_k，堆存储空间
- **数组排序法**：O_n，额外数组空间

### 关键优化点

1. **分治策略**：将O_kn优化为O_nlogk
2. **虚拟头节点**：简化链表合并逻辑
3. **递归优化**：合理的递归边界处理
4. **内存管理**：复用原有节点，避免额外分配

### 边界情况处理

1. **空数组**：直接返回null
2. **单个链表**：直接返回该链表
3. **包含空链表**：跳过空链表处理
4. **所有链表为空**：返回null

### 实际应用场景

1. **外部排序**：合并多个已排序的文件
2. **分布式系统**：合并多个节点的排序结果
3. **数据库**：多路归并排序的实现
4. **搜索引擎**：合并多个索引的结果

### 算法扩展

```mermaid
graph TD
    A[算法扩展] --> B[归并排序]
    A --> C[外部排序]
    A --> D[多路归并]
    A --> E[分布式归并]
    
    B --> F[分治思想应用]
    C --> G[大数据处理]
    D --> H[K路归并算法]
    E --> I[分布式计算]
    
    F --> J[算法模式复用]
    G --> J
    H --> J
    I --> J
```

### 性能优化技巧

```mermaid
graph TD
    A[性能优化] --> B[算法选择]
    A --> C[数据结构优化]
    A --> D[内存优化]
    A --> E[并行化]
    
    B --> F[根据K值选择算法]
    C --> G[堆vs分治权衡]
    D --> H[原地操作减少分配]
    E --> I[多线程分治]
    
    F --> J[实际性能提升]
    G --> J
    H --> J
    I --> J
```

### 测试用例设计

```mermaid
graph TD
    A[测试用例] --> B[基础功能]
    A --> C[边界情况]
    A --> D[性能测试]
    
    B --> E[正常合并]
    B --> F[重复元素]
    C --> G[空数组空链表]
    C --> H[单链表]
    D --> I[大规模数据]
    D --> J[极端K值]
    
    E --> K[验证正确性]
    F --> K
    G --> K
    H --> K
    I --> L[验证性能]
    J --> L
```

这个问题的关键在于**理解分治算法的优势**和**掌握链表合并的基本操作**，通过递归分治将复杂的多路归并问题转化为简单的两路归并问题。
