# 1248. 统计「优美子数组」

## 描述

给你一个整数数组 nums 和一个整数 k。如果某个连续子数组中恰好有 k 个奇数数字，我们就认为这个子数组是「优美子数组」。

请返回这个数组中 「优美子数组」 的数目。

## 示例 1

输入：nums = [1,1,2,1,1], k = 3
输出：2
解释：包含 3 个奇数的子数组是 [1,1,2,1] 和 [1,2,1,1] 。

## 示例 2

输入：nums = [2,4,6], k = 1
输出：0
解释：数列中不包含任何奇数，所以不存在优美子数组。

## 示例 3

输入：nums = [2,2,2,1,2,2,1,2,2,2], k = 2
输出：16

## 提示

- 1 <= nums.length <= 50000
- 1 <= nums[i] <= 10^5
- 1 <= k <= nums.length

## 解题思路

### 方法一：前缀和 + 哈希表（推荐）

**核心思想**：
- 将奇数视为1，偶数视为0，问题转化为求前缀和差值为k的子数组个数
- 使用哈希表记录每个前缀和出现的次数

**算法步骤**：
1. 遍历数组，计算前缀和（只统计奇数个数）
2. 对于每个位置i，查找前缀和为 `prefixSum[i] - k` 的位置个数
3. 更新哈希表中当前前缀和的出现次数

**时间复杂度**：O(n)
**空间复杂度**：O(n)

### 方法二：滑动窗口

**核心思想**：
- 使用双指针维护一个包含恰好k个奇数的窗口
- 统计所有可能的优美子数组

**算法步骤**：
1. 使用left和right指针维护窗口
2. 当窗口内奇数个数等于k时，计算以right结尾的优美子数组个数
3. 移动left指针直到窗口内奇数个数小于k

**时间复杂度**：O(n)
**空间复杂度**：O(1)

### 方法三：数学方法

**核心思想**：
- 找到所有奇数的位置
- 对于每k个连续的奇数，计算它们能形成多少个子数组

**算法步骤**：
1. 记录所有奇数的位置
2. 对于每k个连续的奇数，计算左右边界
3. 计算这k个奇数能形成的子数组个数

**时间复杂度**：O(n)
**空间复杂度**：O(n)

## 代码实现

```go
// 方法一：前缀和 + 哈希表
func numberOfSubarrays(nums []int, k int) int {
    count := make(map[int]int)
    count[0] = 1  // 前缀和为0的情况
    
    prefixSum := 0
    result := 0
    
    for _, num := range nums {
        if num%2 == 1 {
            prefixSum++
        }
        result += count[prefixSum-k]
        count[prefixSum]++
    }
    
    return result
}
```

## 复杂度分析

- **时间复杂度**：O(n)，只需要遍历一次数组
- **空间复杂度**：O(n)，哈希表存储前缀和

## 测试用例

```go
func main() {
    // 测试用例1
    nums1 := []int{1, 1, 2, 1, 1}
    k1 := 3
    fmt.Printf("测试用例1: nums=%v, k=%d, 结果=%d\n", nums1, k1, numberOfSubarrays(nums1, k1))
    
    // 测试用例2
    nums2 := []int{2, 4, 6}
    k2 := 1
    fmt.Printf("测试用例2: nums=%v, k=%d, 结果=%d\n", nums2, k2, numberOfSubarrays(nums2, k2))
    
    // 测试用例3
    nums3 := []int{2, 2, 2, 1, 2, 2, 1, 2, 2, 2}
    k3 := 2
    fmt.Printf("测试用例3: nums=%v, k=%d, 结果=%d\n", nums3, k3, numberOfSubarrays(nums3, k3))
}
```

