# 62. 不同路径

## 题目描述

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

## 示例 1：

![adxmsI](./images/1697422740-adxmsI-image.png)

输入：m = 3, n = 7
输出：28

## 示例 2：

输入：m = 3, n = 2
输出：3
解释：
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右
3. 向下 -> 向右 -> 向下

## 示例 3：

输入：m = 7, n = 3
输出：28

## 示例 4：

输入：m = 3, n = 3
输出：6

## 提示：

- 1 <= m, n <= 100
- 题目数据保证答案小于等于 2 * 10^9

## 解题思路

### 问题分析

这是一道经典的**路径计数动态规划**问题。机器人从左上角走到右下角，每次只能向右或向下移动，求总共有多少条不同的路径。

### 核心思想

从数学角度看，机器人需要走 `(m-1)` 步向右，`(n-1)` 步向下，总共 `(m+n-2)` 步。问题转化为：在 `(m+n-2)` 个位置中选择 `(m-1)` 个位置向右走的组合数，即 `C(m+n-2, m-1)`。

但用动态规划更容易理解和实现：
- **状态定义**：`dp[i][j]` 表示到达位置 `(i,j)` 的路径数
- **状态转移**：`dp[i][j] = dp[i-1][j] + dp[i][j-1]`
- **边界条件**：第一行和第一列都是1（只有一条路径）

### 算法流程图

```mermaid
flowchart TD
    A[开始] --> B[输入m×n网格大小]
    B --> C[初始化DP表格]
    C --> D[设置边界条件]
    D --> E{遍历每个位置}
    E --> F[计算当前位置路径数]
    F --> G[dp[i][j] = dp[i-1][j] + dp[i][j-1]]
    G --> H{是否遍历完毕?}
    H -->|否| E
    H -->|是| I[返回dp[m-1][n-1]]
    I --> J[结束]
    
    style A fill:#e1f5fe
    style J fill:#c8e6c9
    style G fill:#fff3e0
```

### 状态转移详解

```mermaid
graph TD
    A[状态转移方程] --> B[dp[i][j] = dp[i-1][j] + dp[i][j-1]]
    B --> C[上方路径数]
    B --> D[左方路径数]
    C --> E[从上方到达当前位置]
    D --> F[从左方到达当前位置]
    E --> G[累加得到总路径数]
    F --> G
    
    subgraph "边界条件"
        H[dp[0][j] = 1] --> I[第一行只能向右]
        J[dp[i][0] = 1] --> K[第一列只能向下]
    end
    
    style B fill:#ffcdd2
    style G fill:#c8e6c9
```

### 优化策略对比

```mermaid
graph LR
    A[优化方案] --> B[二维DP]
    A --> C[一维DP]
    A --> D[数学公式]
    A --> E[记忆化递归]
    
    B --> B1[空间O(m×n)]
    B --> B2[时间O(m×n)]
    B --> B3[易理解]
    
    C --> C1[空间O(min(m,n))]
    C --> C2[时间O(m×n)]
    C --> C3[滚动数组]
    
    D --> D1[空间O(1)]
    D --> D2[时间O(min(m,n))]
    D --> D3[组合数学]
    
    E --> E1[空间O(m×n)]
    E --> E2[时间O(m×n)]
    E --> E3[自顶向下]
    
    style A fill:#e3f2fd
    style D fill:#c8e6c9
```

### 解法复杂度分析

```mermaid
graph TD
    A[算法复杂度对比] --> B[二维动态规划]
    A --> C[一维动态规划]
    A --> D[数学公式法]
    A --> E[记忆化递归]
    A --> F[递归回溯]
    
    B --> B1[时间: O(m×n)]
    B --> B2[空间: O(m×n)]
    B --> B3[最易理解]
    
    C --> C1[时间: O(m×n)]
    C --> C2[空间: O(min(m,n))]
    C --> C3[空间优化]
    
    D --> D1[时间: O(min(m,n))]
    D --> D2[空间: O(1)]
    D --> D3[最优解法]
    
    E --> E1[时间: O(m×n)]
    E --> E2[空间: O(m×n)]
    E --> E3[自然思维]
    
    F --> F1[时间: O(2^{m+n})]
    F --> F2[空间: O(m+n)]
    F --> F3[会超时]
    
    style D fill:#4caf50
    style F fill:#f44336
```

## 算法实现要点

1. **动态规划核心**：每个位置的路径数等于上方和左方路径数之和
2. **边界处理**：第一行和第一列初始化为1
3. **空间优化**：可以使用一维数组滚动计算
4. **数学优化**：直接计算组合数 `C(m+n-2, m-1)`
5. **溢出预防**：使用long类型防止大数溢出

## 相关题目

- LeetCode 63. 不同路径 II（有障碍物）
- LeetCode 64. 最小路径和
- LeetCode 120. 三角形最小路径和
- LeetCode 174. 地下城游戏
