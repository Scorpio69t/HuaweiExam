# 17. 电话号码的字母组合

## 题目描述

给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

![mfIHZs](./images/1752723054-mfIHZs-image.png)

## 示例 1：

输入：digits = "23"
输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]

## 示例 2：

输入：digits = ""
输出：[]

## 示例 3：

输入：digits = "2"
输出：["a","b","c"]

## 提示：

- 0 <= digits.length <= 4
- digits[i] 是范围 ['2', '9'] 的一个数字。

## 解题思路

这道题要求根据电话号码的数字组合，生成所有可能的字母组合。这是一个经典的**回溯算法**问题，需要枚举所有可能的组合。每个数字对应3-4个字母，需要生成所有可能的排列组合。

### 算法分析

这道题的核心思想是**回溯枚举**，主要解法包括：

1. **回溯法**：使用递归和回溯生成所有组合（推荐）
2. **迭代法**：使用队列进行层序遍历
3. **优化版本**：使用strings.Builder提高字符串操作效率
4. **BFS方法**：广度优先搜索生成组合
5. **递归分治**：使用分治思想逐步构建组合

### 问题本质分析

```mermaid
graph TD
    A[电话号码字母组合] --> B[数字映射]
    B --> C[组合生成]
    C --> D[回溯枚举]
    
    B --> E[2→abc, 3→def, 4→ghi]
    B --> F[5→jkl, 6→mno, 7→pqrs]
    B --> G[8→tuv, 9→wxyz]
    
    C --> H[每个位置选择字母]
    C --> I[生成所有可能组合]
    D --> J[递归回溯]
    
    E --> K[映射关系建立]
    F --> K
    G --> K
    H --> L[组合策略]
    I --> L
    J --> L
```

### 回溯法详解

```mermaid
flowchart TD
    A[输入digits字符串] --> B{digits为空?}
    B -->|是| C[返回空数组]
    B -->|否| D[初始化结果数组]
    
    D --> E[调用回溯函数backtrack]
    E --> F[backtrack(index=0, current="")]
    
    F --> G{index == len(digits)?}
    G -->|是| H[添加current到结果]
    G -->|否| I[获取当前数字对应的字母]
    
    H --> J[返回结果]
    I --> K[遍历每个字母]
    
    K --> L[选择当前字母]
    L --> M[递归调用backtrack(index+1)]
    M --> N[回溯：移除当前字母]
    N --> O{还有字母?}
    
    O -->|是| K
    O -->|否| P[返回上一层]
    
    G --> Q[终止条件处理]
    Q --> R[结果收集]
```

### 组合生成过程可视化

```mermaid
graph TD
    A["输入: digits = '23'"] --> B["数字映射: 2→abc, 3→def"]
    
    B --> C["第1层: 选择2的字母"]
    C --> D["选择'a' → current='a'"]
    C --> E["选择'b' → current='b'"]
    C --> F["选择'c' → current='c'"]
    
    D --> G["第2层: 选择3的字母"]
    E --> H["第2层: 选择3的字母"]
    F --> I["第2层: 选择3的字母"]
    
    G --> J["选择'd' → 'ad'"]
    G --> K["选择'e' → 'ae'"]
    G --> L["选择'f' → 'af'"]
    
    H --> M["选择'd' → 'bd'"]
    H --> N["选择'e' → 'be'"]
    H --> O["选择'f' → 'bf'"]
    
    I --> P["选择'd' → 'cd'"]
    I --> Q["选择'e' → 'ce'"]
    I --> R["选择'f' → 'cf'"]
    
    J --> S["最终结果: [ad,ae,af,bd,be,bf,cd,ce,cf]"]
    K --> S
    L --> S
    M --> S
    N --> S
    O --> S
    P --> S
    Q --> S
    R --> S
```

### 数字映射关系

```mermaid
graph TD
    A[数字映射表] --> B[2 → abc]
    A --> C[3 → def]
    A --> D[4 → ghi]
    A --> E[5 → jkl]
    A --> F[6 → mno]
    A --> G[7 → pqrs]
    A --> H[8 → tuv]
    A --> I[9 → wxyz]
    
    B --> J[3个字母]
    C --> J
    D --> J
    E --> J
    F --> J
    G --> K[4个字母]
    H --> J
    I --> K
    
    J --> L[标准按键]
    K --> M[扩展按键]
    L --> N[组合数量计算]
    M --> N
```

### 各种解法对比

```mermaid
graph TD
    A[解法对比] --> B[回溯法]
    A --> C[迭代法]
    A --> D[优化版本]
    A --> E[BFS方法]
    A --> F[递归分治]
    
    B --> G[时间O_4^n空间O_n]
    C --> H[时间O_4^n空间O_4^n]
    D --> I[时间O_4^n空间O_n]
    E --> J[时间O_4^n空间O_4^n]
    F --> K[时间O_4^n空间O_n]
    
    B --> L[推荐解法]
    C --> M[队列实现]
    D --> N[性能最优]
    E --> O[层序遍历]
    F --> P[分治思想]
    
    L --> Q[平衡性能和可读性]
    M --> Q
    N --> Q
    O --> Q
    P --> Q
```

### 算法流程图

```mermaid
flowchart TD
    A[开始] --> B{digits为空?}
    B -->|是| C[返回空数组]
    B -->|否| D[初始化结果数组]
    
    D --> E[调用backtrack(0, '')]
    E --> F{index >= len(digits)?}
    
    F -->|是| G[添加current到结果]
    F -->|否| H[获取当前数字的字母]
    
    G --> I[返回结果]
    H --> J[遍历每个字母]
    
    J --> K[选择当前字母]
    K --> L[递归backtrack(index+1)]
    L --> M[回溯：移除字母]
    M --> N{还有字母?}
    
    N -->|是| J
    N -->|否| O[返回]
    
    F --> P[递归终止条件]
    P --> Q[结果收集和返回]
```

### 边界情况处理

```mermaid
graph TD
    A[边界情况] --> B[空字符串]
    A --> C[单个数字]
    A --> D[多个数字]
    A --> E[包含7或9]
    
    B --> F[返回空数组]
    C --> G[返回对应字母数组]
    D --> H[正常回溯处理]
    E --> I[处理4个字母的情况]
    
    F --> J[特殊情况处理]
    G --> J
    H --> J
    I --> J
```

### 时间复杂度分析

```mermaid
graph TD
    A[时间复杂度分析] --> B[组合数量计算]
    B --> C[每个数字的字母数]
    C --> D[总体复杂度]
    
    B --> E[3^n 或 4^n]
    C --> F[大部分数字3个字母]
    C --> G[7和9有4个字母]
    D --> H[O_4^n]
    
    E --> I[最坏情况]
    F --> J[平均情况]
    G --> J
    H --> K[指数级增长]
    I --> K
    J --> K
```

### 空间复杂度分析

```mermaid
graph TD
    A[空间复杂度分析] --> B[递归调用栈]
    B --> C[结果存储]
    C --> D[总体空间复杂度]
    
    B --> E[O_n]
    C --> F[O_4^n]
    D --> G[O_4^n]
    
    E --> H[递归深度]
    F --> H
    G --> I[结果数组大小]
    H --> I
```

### 关键优化点

```mermaid
graph TD
    A[优化策略] --> B[字符串操作优化]
    A --> C[数据结构选择]
    A --> D[内存管理]
    
    B --> E[使用strings.Builder]
    C --> F[数组替代map]
    D --> G[避免不必要的内存分配]
    
    E --> H[减少字符串拼接开销]
    F --> H
    G --> H
```

### 实际应用场景

```mermaid
graph TD
    A[应用场景] --> B[电话键盘]
    A --> C[密码生成]
    A --> D[组合枚举]
    A --> E[游戏设计]
    
    B --> F[手机拨号界面]
    C --> G[密码破解工具]
    D --> H[排列组合计算]
    E --> I[文字游戏]
    
    F --> J[核心算法组件]
    G --> J
    H --> J
    I --> J
```

### 测试用例设计

```mermaid
graph TD
    A[测试用例] --> B[基础功能]
    A --> C[边界情况]
    A --> D[特殊情况]
    
    B --> E[正常数字组合]
    B --> F[多个数字]
    B --> G[不同长度]
    
    C --> H[空字符串]
    C --> I[单个数字]
    C --> J[最大长度]
    
    D --> K[包含7或9]
    D --> L[重复数字]
    D --> M[连续数字]
    
    E --> N[验证正确性]
    F --> N
    G --> N
    H --> N
    I --> N
    J --> N
    K --> O[验证特殊规则]
    L --> O
    M --> O
```

### 代码实现要点

1. **回溯策略**：
   - 使用递归函数进行深度优先搜索
   - 在每个位置尝试所有可能的字母
   - 到达叶子节点时收集结果

2. **状态管理**：
   - 维护当前构建的字符串
   - 记录当前处理的位置
   - 正确进行回溯操作

3. **映射关系**：
   - 建立数字到字母的映射表
   - 处理7和9的4个字母情况
   - 使用数组或map存储映射

4. **边界处理**：
   - 空字符串返回空数组
   - 单个数字直接返回对应字母
   - 确保所有情况都有正确输出

5. **性能优化**：
   - 使用strings.Builder减少字符串拼接开销
   - 避免不必要的内存分配
   - 选择合适的递归深度

这个问题的关键在于**理解回溯算法的核心思想**和**掌握递归状态管理**，通过深度优先搜索枚举所有可能的字母组合。特别是回溯操作，需要在每次递归调用后正确恢复状态，确保能够尝试所有可能的组合。时间复杂度为O(4^n)，其中n是digits的长度，因为每个数字最多对应4个字母。

